C--**--CH183--524--Fix--27:5:1999
C--**--CH182--524--P:LAP--26:5:1999
C--**--CH181--524--P:MC--26:5:1999
C--**--CH178--524--P:CAP--26:5:1999
C--**--CH160--524--A:H--20:5:1999
C--**--CH159--524--C:D--20:5:1999
C--**--CH158--524--U:D--20:5:1999
C TEST PROGRAM FOR MP PACKAGE (VARIABLE PRECISION VERSION)
C
C THIS PROGRAM COMPUTES THE CONSTANTS GIVEN IN APPENDIX A
C OF KNUTH, THE ART OF COMPUTER PROGRAMMING, VOL. 3.
C THE CONSTANTS ARE PRINTED IN THE SAME ORDER AS IN KNUTH.
C THE CONSTANTS ARE GIVEN TO HIGH PRECISION IN -
C KNUTHS CONSTANTS TO 1000 DECIMAL AND 1100 OCTAL PLACES
C (BY R. P. BRENT), ANU COMPUTER CENTRE, TECH. REPORT
C NUMBER 47, 1975 (SUBMITTED TO MATH. COMP. UMT FILE).
C
C THE OUTPUT LOGICAL UNIT NUMBER AND THE NUMBER OF DECIMAL
C PLACES FOR WORKING AND OUTPUT ARE READ FROM UNIT 5 IN
C 2I4 FORMAT.  WE ASSUME T .LE. 100, IF NOT THE
C DIMENSION STATEMENTS AND CALL TO MPSET MUST BE CHANGED.
C
C SOME EXECUTION TIMES ARE -
C UNIVAC 1108 (FOR SE1D UNDER EXEC 8)
C    40D       4.420 SECONDS
C    60D       6.981
C    80D      10.293
C   100D      13.970
C   200D      42.083
C   400D     161.524
C  1000D    1065.567
C DEC PDP10 (KA10) (F10, NOOPT)
C    40D      10.98  SECONDS
C    60D      19.12
C    80D      26.74
C   100D      36.16
C   200D     114.70
C   400D     449.52
C IBM 360/50 (FTN H, OPT = 2) (SLOWER VERSION THAN CURRENT ONE)
C    40D      25.039 SECONDS
C    60D      42.461
C    80D      58.859
C   100D      83.166
C   200D     259.078
C IBM 360/91 (FTN H EXTENDED, OPT = 2) (SLOWER VERSION)
C    40D       2.20 SECONDS
C IBM 370/168 (FTN H EXTENDED, OPT = 2) (SLOWER VERSION)
C    40D       1.66 SECONDS
C PDP 11/45 (DOS, NO FLOATING-POINT HARDWARE) (SLOWER VERSION)
C    40D     128  SECONDS
C    60D     226
C    80D     370
C   100D     548
C CYBER 76 (FTN 4.2, OPT = 1) (SLOWER VERSION)
C    40D      0.478 SECONDS
C
C TO RUN TESTV THE FOLLOWING MP ROUTINES ARE REQUIRED -
C MPABS, MPADD, MPADDI, MPADDQ, MPADD2, MPADD3, MPART1, MPCHK,
C MPCIM, MPCLR, MPCMF, MPCMI, MPCMPI, MPCMPR, MPCMR, MPCOMP, MPCOS,
C MPCQM, MPCRM, MPDIV, MPDIVI, MPERR, MPEUL, MPEXP, MPEXP1, MPEXT,
C MPGAMQ, MPGCD, MPLN, MPLNI, MPLNS, MPL235, MPMAXR, MPMLP,
C MPMUL, MPMULI, MPMULQ, MPMUL2, MPNZR, MPOUT, MPOUT2, MPOVFL,
C MPPI, MPPWR, MPQPWR, MPREC, MPROOT, MPSET, MPSIN, MPSIN1,
C MPSQRT, MPSTR, MPSUB, MPUNFL, MP40D, MP40E, AND TIMEMP.
C SEE COMMENTS IN TIMEMP BEFORE RUNNING TESTV.
C
C MPLN REQUIRES SPACE 6T+14 AND WE HAVE T .LE. 100
C TEMPORARY MP VARIABLES REQUIRE SPACE T+2
C
C READ OUTPUT UNIT AND PRECISION FROM UNIT 5,
C STOPPING IF SECOND NUMBER IS .LE. 0
C     .. Parameters ..
      INTEGER RMAX,TMAX
      PARAMETER (RMAX=15000,TMAX=100)
C     ..
C     .. Scalars in Common ..
      INTEGER B,LUN,M,MXR,T
C     ..
C     .. Arrays in Common ..
      INTEGER R(RMAX)
C     ..
C     .. Local Scalars ..
      REAL T1
      INTEGER I,IBT,IDECPL,LUN1,NIN,NOUT
C     ..
C     .. Local Arrays ..
      INTEGER PHI(TMAX+2),PI(TMAX+2),X(TMAX+2),Y(TMAX+2)
C     ..
C     .. External Functions ..
      REAL TIMEMP
      INTEGER I1MACH
      EXTERNAL TIMEMP,I1MACH
C     ..
C     .. External Subroutines ..
      EXTERNAL MP40D,MPADD,MPADDQ,MPCIM,MPCOS,MPCQM,MPDIV,MPDIVI,MPEUL,
     +         MPEXP,MPGAMQ,MPLN,MPLNI,MPMUL,MPMULQ,MPPI,MPQPWR,MPREC,
     +         MPSET,MPSIN,MPSQRT,MPSTR
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC FLOAT,IABS,INT,SQRT
C     ..
C     .. Common blocks ..
      COMMON B,T,M,LUN,MXR,R
C     ..
      NIN = I1MACH(1)
      NOUT = I1MACH(2)
      LUN1 = NOUT
   10 READ (NIN,FMT=9000) IDECPL
      IF (IDECPL.LE.0) STOP
      LUN = LUN1
C ASSUMED THAT TIMEMP(0) GIVES TIME USED OR TIME OF DAY IN
C FLOATING-POINT SECONDS.
      T1 = TIMEMP(0)
      CALL MPSET(LUN1,IDECPL,TMAX+2,6*TMAX+14)
      WRITE (LUN,FMT=9010) B,T
C
C COMPUTE SQRT(2), SQRT(3), SQRT(5) AND SQRT(10)
      DO 20 I = 2,5
          CALL MPQPWR((5*I)/4+4* (I/5),1,1,2,X)
          CALL MP40D(IDECPL,X)
   20 CONTINUE
C COMPUTE 2**(1/3) AND 3**(1/3)
      DO 30 I = 2,3
          CALL MPQPWR(IABS(I),1,1,3,X)
          CALL MP40D(IDECPL,X)
   30 CONTINUE
C COMPUTE 2**(1/4)
      CALL MPQPWR(2,1,1,4,X)
      CALL MP40D(IDECPL,X)
C COMPUTE LN(2), LN(3) AND LN(10)
      DO 40 I = 2,4
          CALL MPLNI(I+6* (I/4),X)
          CALL MP40D(IDECPL,X)
   40 CONTINUE
C COMPUTE 1/LN(2) AND 1/LN(10)
C COULD HAVE SAVED ABOVE RESULTS TO SPEED UP HERE
      DO 50 I = 1,2
          CALL MPLNI(8*I-6,X)
          CALL MPREC(X,X)
          CALL MP40D(IDECPL,X)
   50 CONTINUE
C COMPUTE PI, PI/180, 1/PI, PI**2, SQRT(PI)
      CALL MPPI(PI)
      CALL MP40D(IDECPL,PI)
      CALL MPDIVI(PI,180,Y)
      CALL MP40D(IDECPL,Y)
      CALL MPREC(PI,Y)
      CALL MP40D(IDECPL,Y)
      CALL MPMUL(PI,PI,Y)
      CALL MP40D(IDECPL,Y)
      CALL MPSQRT(PI,Y)
      CALL MP40D(IDECPL,Y)
C COMPUTE GAMMA (1/3)
      CALL MPGAMQ(1,3,X)
      CALL MP40D(IDECPL,X)
C COMPUTE GAMMA (2/3) FROM GAMMA (1/3) (WE COULD
C ALSO CALL MPGAMQ (2, 3, X))
      CALL MPQPWR(3,4,1,2,Y)
      CALL MPMUL(X,Y,X)
      CALL MPDIV(PI,X,X)
      CALL MP40D(IDECPL,X)
C COMPUTE E, 1/E, AND E**2
      CALL MPCIM(1,X)
      CALL MPEXP(X,X)
      CALL MP40D(IDECPL,X)
      CALL MPREC(X,Y)
      CALL MP40D(IDECPL,Y)
      CALL MPMUL(X,X,Y)
      CALL MP40D(IDECPL,Y)
C COMPUTE EULERS CONSTANT (GAMMA)
      CALL MPEUL(X)
      CALL MP40D(IDECPL,X)
C COMPUTE LN(PI), PHI
      CALL MPLN(PI,Y)
      CALL MP40D(IDECPL,Y)
      CALL MPQPWR(5,4,1,2,Y)
      CALL MPADDQ(Y,1,2,PHI)
      CALL MP40D(IDECPL,PHI)
C COMPUTE EXP(GAMMA)  (GAMMA IS IN X)
      CALL MPEXP(X,X)
      CALL MP40D(IDECPL,X)
C COMPUTE EXP(PI/4)
      CALL MPDIVI(PI,4,X)
      CALL MPEXP(X,X)
      CALL MP40D(IDECPL,X)
C COMPUTE SIN(1) AND COS(1)
      CALL MPCIM(1,X)
      CALL MPSIN(X,Y)
      CALL MP40D(IDECPL,Y)
      CALL MPCOS(X,X)
      CALL MP40D(IDECPL,X)
C COMPUTE ZETA(3) USING A SERIES OF GOSPER
C COULD ALSO USE MPZETA (3, X) BUT THIS NEEDS MORE SPACE
      CALL MPCQM(5,4,X)
      CALL MPSTR(X,Y)
      I = 0
C COMPUTE UPPER BOUND ON I SO THAT
C (4*I+2)*(I+1)**2 WILL NOT OVERFLOW BELOW
      IBT = INT(8.0*SQRT(FLOAT(B))) - 1
      IF (IBT.GT. (B/32)) IBT = B/32
C LOOP TO SUM SERIES
   60 I = I + 1
C IF I TOO LARGE THE CALL TO MPMULQ HAS TO BE SPLIT UP
      IF (I.GE.IBT) GO TO 70
      CALL MPMULQ(Y,- (I**3), (4*I+2)* (I+1)**2,Y)
      GO TO 80
C HERE THE ABOVE CALL IS SPLIT UP
   70 CALL MPMULQ(Y,I,I+1,Y)
      CALL MPMULQ(Y,I,I+1,Y)
      CALL MPMULQ(Y,-I,4*I+2,Y)
   80 CALL MPADD(X,Y,X)
C LOOP UNTIL EXPONENT OF Y IS SMALL.  SINCE WE GET AT
C LEAST 2 BITS/TERM, NOT MANY ITERATIONS ARE NECESSARY.
      IF ((Y(1).NE.0) .AND. ((Y(2)+T).GT.0)) GO TO 60
      CALL MP40D(IDECPL,X)
C COMPUTE LN(PHI), 1/LN(PHI), AND -LN(LN(2))
      CALL MPLN(PHI,X)
      CALL MP40D(IDECPL,X)
      CALL MPREC(X,X)
      CALL MP40D(IDECPL,X)
      CALL MPLNI(2,X)
      CALL MPLN(X,X)
      X(1) = -X(1)
      CALL MP40D(IDECPL,X)
C COMPUTE ELAPSED TIME
      T1 = TIMEMP(0) - T1
      WRITE (LUN,FMT=9020) IDECPL,T1
      GO TO 10

 9000 FORMAT (I4)
 9010 FORMAT ('1TESTV OF MP PACKAGE,   BASE =',I9,',  DIGITS =',I3,///)
 9020 FORMAT (//' END OF TEST USING',I5,' DECIMAL PLACES,',' TIME USED',
     +       ' WAS',F10.4,' SECONDS',///)
      END
      REAL FUNCTION TIMEMP(I)
C CALLED BY TESTV MAIN PROGRAM, SHOULD RETURN THE EXECUTION
C TIME IN FLOATING-POINT SECONDS FROM SOME ARBITRARY POINT.
C THE ARGUMENT I IS A DUMMY
C *** REPLACE THE FOLLOWING STATEMENTS BY SUITABLE MACHINE-
C     DEPENDENT STATEMENTS,
C FOR EXAMPLE -
C
C ON UNIVAC 1108 USE
C     TIMEMP = FLOAT(JOBTIM(0))/1000E0
C
C ON IBM 360 USE
C     TIMEMP = TIMREM(0)    OR    TIMEMP = TIME(0)
C
C ON PDP 11/45 USE
C     CALL TIME (I1, I2)
C     TIMEMP = (FLOAT(I1)*32768.0 + FLOAT(I2))/50.0
C
C     .. Parameters ..
      INTEGER RMAX
      PARAMETER (RMAX=15000)
C     ..
C     .. Scalar Arguments ..
      INTEGER I
C     ..
C     .. Scalars in Common ..
      INTEGER B,LUN,M,MXR,T
C     ..
C     .. Arrays in Common ..
      INTEGER R(RMAX)
C     ..
C     .. External Functions ..
      REAL SECOND
      EXTERNAL SECOND
C     ..
C     .. Common blocks ..
      COMMON B,T,M,LUN,MXR,R
C     ..
      TIMEMP = SECOND()
      RETURN
C
      END
