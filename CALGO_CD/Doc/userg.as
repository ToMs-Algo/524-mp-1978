1
0
0
0
0
0
0                             MP USER'S GUIDE
                              **************
0
0                            RICHARD P. BRENT,
                             COMPUTER CENTRE,
                      AUSTRALIAN NATIONAL UNIVERSITY,
                        BOX 4, CANBERRA, ACT 2600,
                                 AUSTRALIA
0
0                        TECHNICAL REPORT NO. 54,
                  SEPTEMBER 1976 (LAST REVISED AUGUST 1978)
1
0
0
0
0
0                                CONTENTS                        PAGE
                                 ********                        ****
0           1. GENERAL DESCRIPTION OF MP                          1.1
                 RESTRICTIONS AND EFFICIENCY CONSIDERATIONS       1.2
                 HISTORY AND REFERENCES                           1.3
0           2. SUMMARY OF MP ROUTINES                             2.1
0           3. EXAMPLE PROGRAM                                    3.1
0           4. THE AUGMENT INTERFACE                              4.1
                 THE DESCRIPTION DECK                             4.1
                 EXAMPLE PROGRAM (JACOBI) USING AUGMENT           4.3
                 RESERVED WORDS                                   4.5
0           5. INSTALLATION INSTRUCTIONS                          5.1
                 CONVERSION NOTES                                 5.2
0           6. DESCRIPTION OF MP ROUTINES AND TEST PROGRAMS       6.1
                 MP SUBROUTINES                                   6.1
                 MP TEST PROGRAMS                                6.23
0           7. INDEX OF LINE NUMBERS                              7.1
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  1.1
01 GENERAL DESCRIPTION OF MP
 ***************************
0    MP IS A MULTIPLE-PRECISION FLOATING-POINT ARITHMETIC PACKAGE.  IT IS ALMOST
     COMPLETELY MACHINE-INDEPENDENT, AND SHOULD RUN ON ANY MACHINE WITH AN  ANSI
     STANDARD  FORTRAN COMPILER, SUFFICIENT MEMORY, AND A WORDLENGTH OF AT LEAST
     16 BITS.  SOME MODIFICATIONS WOULD BE NECESSARY FOR A  WORDLENGTH  OF  LESS
     THAN 16 BITS.
0    MP HAS BEEN TESTED ON VARIOUS MACHINES INCLUDING A  UNIVAC  1108  (E  LEVEL
     FORTRAN  V),  A UNIVAC 1100/42 (E AND T LEVEL FORTRAN V, ASCII FORTRAN, AND
     RALPH), A DEC 10 (FORTRAN 10 (/NOOPT),  AND  FORTRAN  40),  AN  IBM  360/50
     (FORTRAN  G  AND  FORTRAN H, OPT = 2), AN IBM 360/91 AND 370/168 (FORTRAN H
     EXTENDED, OPT = 2), A CYBER 76 (FTN 4.2, OPT = 1) AND A  PDP  11/45  (DOS).
     THESE  MACHINES  HAVE  EFFECTIVE  INTEGER WORDLENGTHS RANGING FROM 16 TO 48
     BITS.
0    MP  WORKS  WITH NORMALIZED FLOATING-POINT NUMBERS.  THE BASE (B) AND NUMBER
     OF DIGITS (T) ARE ARBITRARY (SUBJECT TO SOME RESTRICTIONS GIVEN BELOW), AND
     MAY BE VARIED DYNAMICALLY.
0    T-DIGIT FLOATING-POINT NUMBERS ARE STORED IN INTEGER  ARRAYS  OF  DIMENSION
     T+2, WITH THE FOLLOWING CONVENTIONS
0          WORD 1 = SIGN (0, -1 OR +1),
           WORD 2 = EXPONENT (TO BASE B),
           WORDS 3 TO T+2 = NORMALIZED FRACTION (ONE BASE B DIGIT PER WORD).
0    NOTE THAT WORDS 2 TO T+2 ARE UNDEFINED IF SIGN = 0.
0    ARITHMETIC IS ROUNDED, AND FOUR GUARD DIGITS  ARE  USED  FOR  ADDITION  AND
     MULTIPLICATION,  SO  THE  CORRECTLY  ROUNDED  RESULT  IS  USUALLY PRODUCED.
     DIVISION, SQRT ETC ARE DONE BY NEWTONS METHOD, BUT GIVE THE EXACT RESULT IF
     IT  CAN  BE  REPRESENTED  WITH T-2 DIGITS. OTHER ROUTINES (MPSIN, MPLN ETC)
     USUALLY GIVE A RESULT Y =  F(X)  WHICH  COULD  BE  OBTAINED  BY  MAKING  AN
     O(B**(1-T))  PERTURBATION  IN  X,  EVALUATING  F  EXACTLY,  THEN  MAKING AN
     O(B**(1-T)) PERTURBATION IN Y.
0    EXPONENTS  CAN  LIE  IN THE RANGE -M, ... , +M INCLUSIVE, WHERE M IS SET BY
     THE USER.  ON UNDERFLOW DURING AN ARITHMETIC OPERATION, THE RESULT  IS  SET
     TO  ZERO BY SUBROUTINE MPUNFL.  ON OVERFLOW SUBROUTINE MPOVFL IS CALLED AND
     EXECUTION IS TERMINATED WITH AN ERROR MESSAGE.
0    ERROR  MESSAGES  ARE  PRINTED  ON LOGICAL UNIT LUN, WHERE LUN IS SET BY THE
     USER, AND THEN EXECUTION IS TERMINATED BY A CALL TO SUBROUTINE  MPERR.   IT
     IS  ASSUMED  THAT  LOGICAL RECORDS OF UP TO 80 CHARACTERS MAY BE WRITTEN ON
     UNIT LUN.  A WORKING ARRAY OF SIZE MXR (SEE  BELOW)  MUST  BE  PROVIDED  IN
     COMMON.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  1.2
0    THE  PARAMETERS  B, T, M, LUN AND MXR ARE PASSED TO THE UTILITY ROUTINES IN
     COMMON, TOGETHER WITH A WORKING ARRAY R WHICH MUST  BE  SUFFICIENTLY  LARGE
     (SEE BELOW).  MOST ROUTINES USE THE STATEMENTS
0          COMMON B, T, M, LUN, MXR, R
           INTEGER B, T, R(1)
0    AND IT IS ASSUMED THAT MXR IS SET TO THE DIMENSION  OF  R  IN  THE  CALLING
     PROGRAM, AND THAT MXR IS SUFFICIENTLY LARGE (SEE SECTION 6).
0  RESTRICTIONS AND EFFICIENCY CONSIDERATIONS
   ******************************************
0    B (THE BASE) MUST BE AT LEAST 2.
0    T (NUMBER OF DIGITS) MUST BE AT LEAST 2.
0    M (EXPONENT RANGE) MUST BE GREATER THAN T AND LESS  THAN  1/4  THE  LARGEST
     MACHINE-REPRESENTABLE INTEGER.
0    8*B**2-1   MUST  BE  NO  GREATER  THAN  THE  LARGEST  MACHINE-REPRESENTABLE
     INTEGER,  AND  THE  INTEGERS 0, 1, ... , B MUST BE EXACTLY REPRESENTABLE AS
     SINGLE-PRECISION FLOATING-POINT NUMBERS.
0    B**(T-1) SHOULD BE AT LEAST 10**7.
0    B AND T MAY BE SET TO GIVE THE EQUIVALENT OF A SPECIFIED NUMBER OF  DECIMAL
     PLACES  BY  CALLING  MPSET  (SEE  SECTION 6), OR MAY BE SET DIRECTLY BY THE
     USER.  IF MPSET IS NOT CALLED, THE USER MUST REMEMBER TO INITIALIZE M,  LUN
     AMD MXR (SEE ABOVE) AS WELL AS B AND T BEFORE CALLING ANY MP ROUTINES.
0    IT WOULD BE POSSIBLE  TO  USE  LABELLED  COMMON  INSTEAD  OF  BLANK  COMMON
     THROUGHOUT,  AND  SET  DEFAULT  INITIALIZATIONS IN A DATA STATEMENT.  BLANK
     COMMON RATHER THAN LABELLED COMMON IS USED FOR WORKING STORAGE ONLY BECAUSE
     A  CURIOUS  RESTRICTION IN THE ANSI (1966) FORTRAN STANDARD REQUIRES THAT A
     LABELLED COMMON BLOCK BE DECLARED WITH THE SAME LENGTH IN  EACH  SUBPROGRAM
     IN WHICH IT IS DECLARED.
0    FOR EFFICIENCY CHOOSE B FAIRLY LARGE, SUBJECT  TO  THE  RESTRICTIONS  GIVEN
     ABOVE.  FOR EXAMPLE, IF THE WORDLENGTH IS
0          48 BITS, COULD USE B = 4194304 OR 1000000,
           36 BITS, COULD USE B = 65536 OR 10000,
           32 BITS, COULD USE B = 16384 OR 10000,
           24 BITS, COULD USE B = 1024 OR 1000,
           18 BITS, COULD USE B = 128 OR 100,
           16 BITS, COULD USE B = 64 OR 10.
0    AVOID MULTIPLICATION AND DIVISION BY MP  NUMBERS,  AS  THESE  TAKE  O(T**2)
     OPERATIONS,  WHEREAS  MULTIPLICATION  AND  DIVISION  BY  (SINGLE-PRECISION)
     INTEGERS TAKE O(T) OPERATIONS.  SEE THE COMMENTS ON  MPDIV,  MPDIVI,  MPMUL
     AND MPMULI IN SECTION 6.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  1.3
0    MP  NUMBERS  USED  AS  ARGUMENTS  OF SUBROUTINES NEED NOT BE DISTINCT.  FOR
     EXAMPLE,
0          CALL MPADD (X, Y, Y)
     AND
           CALL MPEXP (X, X)
0    ARE  ALLOWABLE.  HOWEVER, DISTINCT ARRAYS WHICH OVERLAP SHOULD NOT BE USED.
0    IT IS ASSUMED  THAT  THE  COMPILER  PASSES  ADDRESSES  OF  ARRAYS  USED  AS
     ARGUMENTS IN SUBROUTINE CALLS (I.E., CALL BY REFERENCE), AND DOES NOT CHECK
     FOR ARRAY BOUNDS VIOLATIONS (EITHER FOR ARGUMENTS OR FOR ARRAYS IN COMMON).
     APART  FROM  THESE VIOLATIONS, MP IS WRITTEN IN ANSI STANDARD FORTRAN (ANSI
     X3.9-1966).  THIS HAS  BEEN  CHECKED  BY  THE  PFORT  VERIFIER.   THE  ONLY
     MACHINE-DEPENDENT ROUTINE IS MPUPK (WHICH UNPACKS CHARACTERS STORED SEVERAL
     TO A WORD).  OTHER ROUTINES WHICH MAY REQUIRE TRIVIAL  CHANGES  ARE  MPSET,
     MPINIT AND TIMEMP (SEE COMMENTS IN SECTIONS 4 AND 6 BELOW).
0  HISTORY AND REFERENCES
   **********************
0    THE FIRST WORKING VERSION OF MP (VERSION 731101) WAS WRITTEN BY R. P. BRENT
     IN  NOVEMBER  1973.   BETWEEN  1973  AND  1978  A  CONSIDERABLE  NUMBER  OF
     IMPROVEMENTS AND ADDITIONS WERE MADE.  THE LAST MAJOR REVISION WAS IN APRIL
     1978, WHEN THE AUGMENT INTERFACE ROUTINES (SEE SECTION 4 BELOW) WERE ADDED.
0    FOR AN INTRODUCTION TO THE DESIGN AND PHILOSOPHY OF MP,  SEE  -  A  FORTRAN
     MULTIPLE-PRECISION  ARITHMETIC  PACKAGE  (BY R. P. BRENT), ACM TRANS. MATH.
     SOFTWARE 4  (MARCH  1978),  57-70.   ADDITIONAL  DETAILS  ARE  GIVEN  IN  -
     ALGORITHM  524 - MP, A FORTRAN MULTIPLE-PRECISION ARITHMETIC PACKAGE, IBID,
     71-81, AND SECTION 6 BELOW.
0    A  PREPROCESSOR  (AUGMENT)  WHICH  FACILITATES THE USE OF THE MP PACKAGE IS
     AVAILABLE. SEE  -  AN  AUGMENT  INTERFACE  FOR  BRENTS  MULTIPLE  PRECISION
     ARITHMETIC  PACKAGE  (BY  R.  P.  BRENT,  J.  A.  HOOPER  AND  J. M. YOHE),
     MATHEMATICS RESEARCH CENTER, UNIVERSITY OF WISCONSIN, MADISON, AUGUST  1978
     (SUBMITTED TO ACM TRANS. MATH. SOFTWARE), AND SECTION 4 BELOW.
0    CORRESPONDENCE CONCERNING MP SHOULD  BE  ADDRESSED  TO  DR.  R.  P.  BRENT,
     COMPUTER  CENTRE,  AUSTRALIAN  NATIONAL UNIVERSITY, BOX 4, CANBERRA, A.C.T.
     2600, AUSTRALIA.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  2.1
02 SUMMARY OF MP ROUTINES
 ************************
0    BASIC ARITHMETIC
0          MPADD, MPADDI, MPADDQ, MPDIV, MPDIVI, MPMUL, MPMULI,  MPMULQ,  MPREC,
           MPSUB
0    POWERS AND ROOTS
0          MPPWR, MPPWR2, MPQPWR, MPROOT, MPSQRT
0    ELEMENTARY FUNCTIONS
0          MPASIN,  MPATAN,  MPCOS,  MPCOSH,  MPEXP, MPLN, MPLNGS, MPLNI, MPSIN,
           MPSINH, MPTAN, MPTANH
0    SPECIAL FUNCTIONS
0          MPBESJ, MPDAW, MPEI,  MPERF,  MPERFC,  MPGAM,  MPGAM,  MPGAMQ,  MPLI,
           MPLNGM
0    CONSTANTS
0          MPBERN, MPEPS, MPEUL, MPMAXR, MPMINR, MPPI, MPPIGL, MPZETA
0    INPUT AND OUTPUT
0          MPDUMP, MPIN, MPINE, MPINF, MPOUT, MPOUTE, MPOUTF, MPOUT2
0    CONVERSION
0          MPCAM,  MPCDM,  MPCIM,  MPCMD,  CPCMDE, MPCMEF, MPCMI, MPCMIM, MPCMR,
           MPCMRE, MPCQM, MPCRM
0    COMPARISON
0          MPCMPA, MPCMPI, MPCMPR, MPCOMP, MPEQ, MPGE, MPGT, MPLE, MPLT, MPNE
0    GENERAL UTILITY ROUTINES
0          MPABS, MPCLR, MPCMF, MPGCDA, MPGCDB, MPINIT,  MPKSTR,  MPMAX,  MPMIN,
           MPNEG, MPPACK, MPPOLY, MPSET, MPSTR, MPUNPK
0    ERROR DETECTION AND HANDLING
0          MPCHK, MPERR, MPOVFL, MPUNFL
0    TEST PROGRAMS
0          EXAMPLE, JACOBI, TEST, TESTV, TEST2
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  2.2
0    AUGMENT INTERFACE ROUTINES
0          MPBASA, MPBASB, MPDGA, MPDGB, MPDIGA, MPDIGB, MPEXPA, MPEXPB, MPMEXA,
           MPMEXB, MPSIGA, MPSIGB
0    MISCELLANEOUS ROUTINES USED BY THE ABOVE
0          MPADD2, MPADD3, MPART1, MPBES2, MPERF2, MPERF3, MPEXP1, MPEXT, MPGCD,
           MPHANK, MPIO, MPLNS, MPL235, MPMLP,  MPMUL2,  MPNZR,  MPSIN1,  MPUPK,
           MP40D, MP40E, MP40F, MP40G, TIMEMP
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  3.1
03 EXAMPLE PROGRAM
 *****************
0    C
     C THIS PROGRAM COMPUTES PI AND EXP(PI*SQRT(163/9)) TO 100
     C DECIMAL PLACES, AND EXP(PI*SQRT(163)) TO 90 DECIMAL PLACES,
     C AND WRITES THEM ON LOGICAL UNIT 6.  EXECUTION
     C TIME ON A UNIVAC 1108 (WITH FORTRAN SE1D) IS 1.051 SECONDS.
     C
     C TO RUN EXAMPLE THE FOLLOWING MP ROUTINES ARE REQUIRED - MPABS,
     C MPADD, MPADDI, MPADD2, MPADD3, MPART1, MPCHK, MPCIM, MPCLR, MPCMF,
     C MPCMI, MPCMPR, MPCMR, MPCOMP, MPCQM, MPCRM, MPDIVI, MPERR,
     C MPEXP, MPEXP1, MPGCD, MPLNI, MPL235, MPMAXR, MPMLP, MPMUL,
     C MPMULI, MPMULQ, MPMUL2, MPNZR, MPOUT, MPOUT2, MPOVFL, MPPI,
     C MPPWR, MPQPWR, MPREC, MPROOT, MPSET, MPSTR, MPSUB, MPUNFL.
     C
     C CORRECT OUTPUT (EXCLUDING HEADINGS) IS AS FOLLOWS
     C
     C                  3.14159265358979323846264338327950288419716939937510
     C                    58209749445923078164062862089986280348253421170680
     C             640320.00000000060486373504901603947174181881853947577148
     C                    57603665918194652218258286942536340815822646477590
     C 262537412640768743.99999999999925007259719818568887935385633733699086
     C                    2707537410378210647910118607312951181346
     C
     C CERTAIN PARAMETERS AND WORKING SPACE IN COMMON.
           COMMON B, T, M, LUN, MXR, R
     C
     C MPEXP REQUIRES 4T+10 WORDS AND WE HAVE T .LE. 62 IF WORDLENGTH
     C AT LEAST 16 BITS, SO 4T+10 .LE. 258.  DIMENSIONS CAN BE REDUCED
     C IF WORDLENGTH IS GREATER THAN 16 BITS.
           INTEGER B, T, R(258)
     C
     C VARIABLES NEED T+2 .LE. 64 WORDS AND ALLOW 110 CHARACTERS FOR
     C DECIMAL OUTPUT
           INTEGER PI(64), X(64), C(110)
     C
     C CALL MPSET TO SET OUTPUT LOGICAL UNIT = 6 AND EQUIVALENT
     C NUMBER OF DECIMAL PLACES TO AT LEAST 110.  THE LAST TWO
     C PARAMETERS ARE THE DIMENSIONS OF PI (OR X) AND R.
           CALL MPSET (6, 110, 64, 258)
     C
     C COMPUTE MULTIPLE-PRECISION PI
           CALL MPPI(PI)
     C
     C CONVERT TO PRINTABLE FORMAT (F110.100) AND WRITE
           CALL MPOUT (PI, C, 110, 100)
           WRITE (LUN, 10) B, T, C
        10 FORMAT (32H1EXAMPLE OF MP PACKAGE,   BASE =, I9,
          $  12H,   DIGITS =, I4 /// 11H PI TO 100D //
          $  11X, 60A1 / 21X, 50A1)
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  3.2
0    C
     C SET X = SQRT(163/9), THEN MULTIPLY BY PI
           CALL MPQPWR (163, 9, 1, 2, X)
           CALL MPMUL (X, PI, X)
     C
     C SET X = EXP(X)
           CALL MPEXP (X, X)
     C
     C CONVERT TO PRINTABLE FORMAT AND WRITE
           CALL MPOUT (X, C, 110, 100)
           WRITE (LUN, 20) C
        20 FORMAT (/ 28H EXP(PI*SQRT(163/9)) TO 100D //
          $        11X, 60A1 / 21X, 50A1)
     C
     C SET X = X**3 = EXP(PI*SQRT(163))
           CALL MPPWR (X, 3, X)
     C
     C WRITE IN FORMAT F110.90
           CALL MPOUT (X, C, 110, 90)
           WRITE (LUN, 30) C
        30 FORMAT (/ 25H EXP(PI*SQRT(163)) TO 90D //
          $        1X, 70A1 / 21X, 40A1)
           STOP
           END
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  4.1
04 THE AUGMENT INTERFACE
 ***********************
0    AUGMENT  IS  A  PREPROCESSOR  WHICH ALLOWS THE INTRODUCTION OF NON-STANDARD
     TYPES  (E.G.  MULTIPLE-PRECISION  NUMBERS)  INTO  FORTRAN  PROGRAMS.    FOR
     DETAILS,  SEE  - THE AUGMENT PRECOMPILER, PARTS 1 AND 2 - (BY F. D. CRARY),
     TECH.  SUMMARY  REPORTS  1469  AND  1470,  MATHEMATICS   RESEARCH   CENTER,
     UNIVERSITY  OF  WISCONSIN, MADISON, DEC. 1974 (REVISED APRIL 1976) AND OCT.
     1975.  SEE ALSO - A VERSATILE PRECOMPILER FOR NONSTANDARD ARITHMETICS - (BY
     F. D. CRARY), TO APPEAR IN ACM TRANS. MATH. SOFTWARE.
0    A DESCRIPTION DECK HAS BEEN  WRITTEN  TO  ENABLE  AUGMENT  TO  BE  USED  IN
     CONJUNCTION  WITH  THE  MP  PACKAGE.   THIS  GREATLY SIMPLIFIES THE TASK OF
     WRITING A PROGRAM FOR A MULTIPLE-PRECISION  COMPUTATION,  OR  CONVERTING  A
     SINGLE (OR DOUBLE) PRECISION ROUTINE TO MULTIPLE PRECISION.
0    FOR EXAMPLE, IF AUGMENT IS USED WE CAN WRITE EXPRESSIONS SUCH AS
0         X = Y + Z*EXP(X+1)/Y
0    WHERE X, Y, AND Z ARE MULTIPLE-PRECISION, INSTEAD OF THE EQUIVALENT
0         CALL MPADDI (X, 1, MPTEMP)
          CALL MPEXP (MPTEMP, MPTEMP)
          CALL MPMUL (Z, MPTEMP, MPTEMP)
          CALL MPDIV (MPTEMP, Y, MPTEMP)
          CALL MPADD (Y, MPTEMP, X)
0    THE AUGMENT INTERFACE  CAN  BE  USED  WITH  MP  VERSION  780420  (OR  LATER
     VERSIONS).   FOR  MORE  DETAILS,  SEE  THE  TECHNICAL  REPORT  - AN AUGMENT
     INTERFACE FOR BRENTS MULTIPLE PRECISION ARITHMETIC  PACKAGE  -  (BY  R.  P.
     BRENT,  J.  A.  HOOPER  AND  J.  M.  YOHE),  MATHEMATICS  RESEARCH  CENTER,
     UNIVERSITY OF WISCONSIN, MADISON, AUGUST 1978 (APPENDIX A OF THIS REPORT IS
     A  CONVENIENT  SUMMARY  OF THE OPERATIONS IMPLEMENTED IN THE MP PACKAGE AND
     THE METHODS OF INVOKING THEM, EITHER DIRECTLY OR VIA AUGMENT.)
0  THE DESCRIPTION DECK
   ********************
0    THE DESCRIPTION DECK WHICH DESCRIBES THE MP PACKAGE IS AS FOLLOWS.
0    *DESCRIBE MULTIPAK
     COMMENT  AUGMENT DESCRIPTION DECK FOR THE MULTIPLE-PRECISION
              ARITHMETIC PACKAGE OF R. P. BRENT, UNIVAC 1100 VERSION.
              THREE TYPES OF VARIABLE ARE DEFINED HERE -
                    MULTIPLE   (STANDARD MULTIPLE-PRECISION NUMBERS),
                    MULTIPAK   (PACKED MULTIPLE-PRECISION NUMBERS), AND
                    INITIALIZE (USED ONLY AS A DEVICE TO PERSUADE
                                AUGMENT TO INITIALIZE THE MP PACKAGE).
              WORKING SPACE SHOULD BE ALLOCATED AND THE MP PACKAGE
              INITIALIZED BY THE DECLARATION
                    INITIALIZE MP
              IN THE MAIN PROGRAM.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  4.2
0             THIS DESCRIPTION DECK ASSUMES THAT MULTIPLE PRECISION NUMBERS
              WILL HAVE NO MORE THAN 10 DIGITS (BASE 65536) FOR A TOTAL
              PRECISION NOT EXCEEDING ABOUT 43 DECIMAL PLACES.  FOR THIS,
              EACH MP NUMBER REQUIRES 12 WORDS (6 IN PACKED FORMAT).
              SEE COMMENTS IN ROUTINE MPINIT FOR THE METHOD OF CHANGING
              THE PRECISION OR ADAPTING TO A MACHINE WITH WORDLENGTH OTHER
              THAN 36 BITS, AND ALSO REGARDING DECLARATION OF BLANK COMMON.
     DECLARE INTEGER(6), KIND SAFE SUBROUTINE, PREFIX MPK
     SERVICE COPY(STR)
     *DESCRIBE MULTIPLE
     DECLARE INTEGER(12), KIND SAFE SUBROUTINE, PREFIX MP
     OPERATOR + (,NULL UNARY, PRV, $), - (NEG, UNARY),
              + (ADD, BINARY3, PRV, $, $, $, COMM), * (MUL),
              - (SUB,,,,,, NONCOMM), / (DIV), ** (PWR2),
              + (ADDI,,,, INTEGER), * (MULI), / (DIVI), ** (PWR),
              .EQ. (EQ, BINARY2, PRV, $, LOGICAL, COMM), .NE. (NE),
              .GE. (GE,,,,, NONCOMM), .GT. (GT), .LE. (LE), .LT. (LT)
     TEST     MPSIGA (SIGA, INTEGER)
     FIELD    SGN (SIGA, SIGB, ($), INTEGER),
              EXPON (EXPA, EXPB), BASE (BASA, BASB), NUMDIG (DIGA, DIGB),
              MAXEXP (MEXA, MEXB), DIGIT (DGA, DGB, ($, INTEGER))
     FUNCTION ABS (ABS, ($), $), ASIN (ASIN), ATAN (ATAN), CMF (CMF),
              CMIM (CMIM), COS (COS), COSH (COSH), DAW (DAW), EI (EI),
              ERF (ERF), ERFC (ERFC), EXP (EXP), EXP1 (EXP1), FRAC (CMF)
              GAM (GAM), INT (CMIM), LI (LI), LN (LN), LOG (LN), LNGM (L
              LNGS (LNGS), LNS (LNS), REC (REC), SIN (SIN), SINH (SINH),
              SQRT (SQRT), TAN (TAN), TANH (TANH),
              ART1 (ART1, (INTEGER)), LN (LNI), LNI (LNI), LOG (LNI),
              ZETA (ZETA), CAM (CAM), CAM (CAM, (HOLLERITH)),
              MAX (MAX, ($, $)), MIN (MIN), GCD (GCDA),
              BESJ (BESJ, ($, INTEGER)), ROOT (ROOT),
              MPINF (INF(SUBROUTINE),($,INTEGER,INTEGER,HOLLERITH),LOGIC
              MPOUTF (OUTF(SUBROUTINE)),
              MPINF (INF(SUBROUTINE), ($, INTEGER, INTEGER, INTEGER)),
              MPOUTF (OUTF(SUBROUTINE)),
              COMP (COMP, ($, $), INTEGER), CMPA (CMPA),
              COMP (CMPI, ($, INTEGER)), COMP (CMPR, ($, REAL)),
              ADDQ (ADDQ, ($, INTEGER, INTEGER), $), MULQ (MULQ),
              QPWR (QPWR, (INTEGER, INTEGER, INTEGER, INTEGER)),
              CQM (CQM, (INTEGER, INTEGER)), CTM (CQM),
              GAM (GAMQ), GAMQ (GAMQ),
              BERN (BERN, (INTEGER, INTEGER), MULTIPAK)
     CONVERSION CTM (CDM, DOUBLE PRECISION, $, UPWARD),
              CTM (CIM, INTEGER), CTM (CRM, REAL),
              CTM (UNPK, MULTIPAK), CTM (CAM, HOLLERITH),
              CTD (CMD(SUBROUTINE), $, DOUBLE PRECISION, DOWNWARD),
              CTI (CMI(SUBROUTINE),, INTEGER),
              CTR (CMR(SUBROUTINE),, REAL), CTP (PACK,, MULTIPAK)
     SERVICE COPY (STR)
     *DESCRIBE INITIALIZE
     DECLARE INTEGER(1), KIND SAFE SUBROUTINE, PREFIX MPI
     SERVICE COPY (STR), INITIAL (NIT)
     COMMENT    END OF AUGMENT DESCRIPTION DECK FOR MP PACKAGE
1                    MP USERS GUIDE (AUGUST 1978)                      P
0  EXAMPLE PROGRAM (JACOBI) USING AUGMENT
   **************************************
0    THE  PROGRAM  WHICH  FOLLOWS ILLUSTRATES THE USE OF THE MP PACKAGE
     AUGMENT INTERFACE.
0    (INSERT MACHINE-DEPENDENT STATEMENTS HERE TO EXECUTE AUGMENT)
0    *BEGIN
     *ENABLE SOURCE, OUTPUT
     C
     C PROGRAM TO VERIFY AN IDENTITY OF JACOBI USING THE MP
     C PACKAGE AND AUGMENT.
     C
     C THE PROGRAM READS A NUMBER X IN FREE-FIELD FORMAT ACCEPTABLE TO
     C MPIN.  IF X IS NON-POSITIVE IT HALTS.  OTHERWISE IT COMPUTES
     C AND PRINTS FN(X), FN(1/X) AND (FN(X)-FN(1/X))/FN(X),
     C WHERE  FN(X) IS THE SUM FROM N = -INFINITY TO +INFINITY OF
     C SQRT(X)*EXP(-PI*(N*X)**2).
     C THE IDENTITY VERIFIED IS   FN(X) = FN(1/X)
     C
     C DECLARE VARIABLES AND INITIALIZE MP PACKAGE.  ON SOME SYSTEMS BLA
     C COMMON MUST BE DECLARED HERE - SEE COMMENTS IN ROUTINE MPINIT.
     C
           LOGICAL ERR
           MULTIPLE X, F1, F2, FN
           INITIALIZE MP
     C
     C READ X FROM UNIT 5 IN (72A1) FORMAT, STOP IF ERROR
     C OR IF X NOT POSITIVE.
     C
        10 IF (MPINF (X, 72, 5, 6H(72A1))) STOP
           IF (X.LE.0) STOP
     C
     C WRITE HEADING, X, FN(X), AND FN(1/X) IN (1X,F50.40) FORMAT
     C
           WRITE (6, 20)
        20 FORMAT (//41H X, FN(X), FN(1/X), (FN(X)-FN(1/X))/FN(X)/)
           ERR = MPOUTF (X, 50, 40, 9H(1X,50A1))
           F1 = FN(X)
           ERR = MPOUTF (F1, 50, 40, 9H(1X,50A1))
           F2 = FN(1/X)
           ERR = MPOUTF (F2, 50, 40, 9H(1X,50A1))
     C
     C WRITE (F1-F2)/F1 IN (1X,F70.60) FORMAT.
     C NOTE THAT AN MP EXPRESSION CAN BE AN ARGUMENT OF MPOUTF.
     C
           ERR = MPOUTF ((F1-F2)/F1, 70, 60, 9H(1X,70A1))
           GO TO 10
           END
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  4.4
0    C
     C MULTIPLE PRECISION FUNCTION FOLLOWS
     C
           FUNCTION FN(X)
     C
     C RETURNS FN(X) = THE SUM FROM N = -INFINITY TO +INFINITY OF
     C SQRT(X)*EXP(-PI*(N*X)**2), ASSUMING X POSITIVE.
     C USES THE OBVIOUS METHOD, SO SLOW IF X SMALL.
     C NOTE THAT X AND FN ARE BOTH TYPE MULTIPLE.
     C
           MULTIPLE FN, X, TM, FAC, PR
           IF (X.LE.0) CALL MPERR
           FN = 0
     C
     C AUGMENT CAN DEAL WITH THE FOLLOWING EXPRESSION AS IT KNOWS THAT X
     C IS TYPE MULTIPLE, SO CALLS MPCAM TO CONVERT 2HPI TO MULTIPLE.
     C
           TM = EXP(-2HPI*X*X)
           PR = TM
           FAC = TM**2
     C
     C LOOP TO SUM INFINITE SERIES
     C WARNING - NUMBER OF ITERATIONS IS PROPORTIONAL TO 1/X
     C
        10 FN = FN + TM
           PR = PR*FAC
           TM = TM*PR
     C
     C TEST FOR CONVERGENCE BY COMPARING EXPONENTS OF FN AND TM.
     C WE COULD ALSO HAVE SAVED THE OLD VALUE OF FN AND SEEN IF
     C STATEMENT 10 CHANGED IT.
     C
           IF (EXPON(FN)-EXPON(TM).LT.NUMDIG(X)) GO TO 10
           FN = SQRT(X)*(2*FN+1)
           RETURN
           END
     *END
0    (INSERT MACHINE-DEPENDENT STATEMENTS HERE TO COMPILE THE OUTPUT
      FROM AUGMENT, LINK WITH PRECOMPILED MP ROUTINES, AND EXECUTE.
      TYPICAL DATA FOLLOWS.)
0    .5
     .3
     10
     1.234567890123456789012345678901234567890123456789
     0
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  4.5
0  RESERVED WORDS
   **************
0    WHEN  WRITING PROGRAMS WHICH USE MP VIA THE AUGMENT INTERFACE, IT IS SAFEST
     TO AVOID USING THE FOLLOWING IDENTIFIERS EXCEPT WITH THEIR RESERVED MEANING
     AS INDICATED BELOW -
0          BASE        SEE DESCRIPTION OF MPBASA AND MPBASB IN SECTION 6.
           CTD         SEE MPCMD.
           CTI         SEE MPCMI.
           CTM         SEE MPCAM, MPCDM, MPCIM, MPCQM, MPCRM, MPUNPK.
           CTP         SEE MPPACK.
           CTR         SEE MPCMR.
           DIGIT       SEE MPDGA AND MPDGB.
           EXPON       SEE MPEXPA AND MPEXPB.
           FRAC        SEE MPCMF.
           GCD         SEE MPGCDA.
           INITIALIZE  SEE MPINIT.
           INT         SEE MPCMIM.
           LOG         SEE MPLN AND MPLNI.
           MAXEXP      SEE MPMEXA AND MPMEXB.
           MPXXXX      (FOR ANY LETTERS OR DIGITS XXXX).
           MULTIPAK    SEE COMMENTS IN DESCRIPTION DECK ABOVE.
           MULTIPLE    SEE COMMENTS IN DESCRIPTION DECK ABOVE.
           NUMDIG      SEE MPDIGA AND MPDIGB.
           SGN         SEE MPSIGA AND MPSIGB.
0    FOR  THE  FOLLOWING,  IF  THE RESERVED WORD IS XXXX, SEE THE DESCRIPTION OF
     MPXXXX IN SECTION 6.
0          ABS, ADDQ, ART1, ASIN, ATAN, BERN, BESJ, CAM, CMF, CMIM, CMPA,  COMP,
           COS,  COSH,  CQM,  DAW,  EI, ERF, ERFC, EXP, EXP1, GAM, GAMQ, LI, LN,
           LNGM, LNGS, LNI, LNS, MAX, MIN, MULQ, QPWR,  REC,  ROOT,  SIN,  SINH,
           SQRT, STR, TAN, TANH, ZETA.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  5.1
05 INSTALLATION INSTRUCTIONS
 ***************************
0    MP IS NORMALLY DISTRIBUTED IN FIVE FILES.
0          FILE 1 - COMMENTS AND EXAMPLE PROGRAM.
           FILE 2 - MP SUBROUTINES (EXCLUDING EXAMPLE AND TEST PROGRAMS).
           FILE 3 - TEST PROGRAMS (NOT USING AUGMENT INTERFACE).
           FILE 4 - THIS USERS GUIDE.
           FILE 5 - AUGMENT DESCRIPTION DECK AND JACOBI PROGRAM USING IT.
0    TO INSTALL MP, READ THESE FIVE FILES.  PRINT FILE 4 (THE USERS GUIDE) USING
     THE FIRST CHARACTER (BLANK, 0 OR 1) AS STANDARD FORTRAN PRINTER CONTROL.
0    CHECK SOURCE OF ROUTINES MPINIT, MPSET, AND  MPUPK  (IN  FILE2),  MAKE  ANY
     NECESSARY  CHANGES, THEN COMPILE ROUTINES IN FILES 2 AND 3 (PREFERABLY WITH
     OPTIMIZATION OPTIONS OFF) AND CHECK YOUR VERSION OF MPUPK.
0    CONVERT  COMPILED ROUTINES FROM FILE 2 INTO A RELOCATABLE LIBRARY.  IF THIS
     IS NOT POSSIBLE, SEE COMMENTS IN THE TEST ROUTINES OR IN SECTION 6 BELOW TO
     FIND OUT WHICH ROUTINES FROM FILE 2 THEY NEED TO RUN.
0    EXECUTE THE PROGRAMS EXAMPLE, TEST AND TEST2 FROM FILE 3 (AFTER LINKING  TO
     REQUIRED  ROUTINES  FROM FILE 2) AND CHECK THAT OUTPUT IS THE SAME AS GIVEN
     IN THE COMMENTS IN THE PROGRAMS OR IN SECTION 6 BELOW.  OUTPUT IS ON UNIT 6
     UNLESS THE FIRST ARGUMENT IN EACH CALL TO MPSET IS CHANGED.
0    IF ALL HAS GONE WELL, TRY RECOMPILING FILE  2  WITH  COMPILER  OPTIMIZATION
     OPTIONS  TURNED ON, AND RERUN TEST PROGRAMS.  ANY PROBLEMS WHICH APPEAR ARE
     PROBABLY DUE TO BUGS IN YOUR COMPILER,  NOT  IN  THE  MP  ROUTINES.   (SUCH
     PROBLEMS  EXIST  WITH  SOME  RELEASES  OF  THE  UNIVAC FTN AND DEC 10 (F10)
     COMPILERS,  FOR  EXAMPLE.)   THE  ROUTINES  WHOSE  OPTIMIZATION   IS   MOST
     WORTHWHILE ARE MPNZR, MPMLP, MPDIVI, MPADD2, MPADD3 AND MPMUL2.
0    IF YOU  WANT  TO  USE  THE  AUGMENT  INTERFACE,  OBTAIN  AUGMENT  FROM  THE
     PROGRAMMING  SERVICES  LIBRARIAN,  MATHEMATICS  RESEARCH CENTER, 610 WALNUT
     STREET, MADISON, WISCONSIN 53706, AND GET IT RUNNING.  THIS SHOULD  NOT  BE
     TOO  HARD IF YOU HAVE A UNIVAC 1100, IBM 360/370, CDC 6000/7000, DEC 10, OR
     HONEYWELL 600/6000, AS  AUGMENT  HAS  ALREADY  BEEN  IMPLEMENTED  ON  THESE
     MACHINES.   (AUGMENT IS WRITTEN MAINLY IN PORTABLE FORTRAN, BUT THERE ARE A
     FEW MACHINE-DEPENDENT ROUTINES.)
0    NEXT,  USE  THE DESCRIPTION DECK SUPPLIED IN FILE 5 AND RUN THE JACOBI TEST
     PROGRAM WHICH FOLLOWS THE DESCRIPTION DECK IN FILE 5 (AFTER INSERTING A FEW
     MACHINE-DEPENDENT  CONTROL  CARDS).   IT  WILL  BE  NECESSARY TO CHANGE THE
     DIMENSION STATEMENTS IN THE DESCRIPTION DECK AND MODIFY ROUTINE  MPINIT  IF
     YOUR MACHINE HAS WORDLENGTH LESS THAN 36 BITS, AND DESIRABLE TO DO LIKEWISE
     IF THE WORDLENGTH IS GREATER THAN 36 BITS.  SEE ALSO THE COMMENTS IN MPINIT
     REGARDING COMMON DECLARATION.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  5.2
0  CONVERSION NOTES
   ****************
0    TO  CONVERT  MPUPK  TO  A  MACHINE WITH NK CHARACTERS PER WORD, NB BITS PER
     CHARACTER, AND WORDLENGTH NB*NK BITS, CHANGE LINE  MP052387  APPROPRIATELY,
     AND REPLACE LINE MP052415 BY
0          TEMP = OR(AND(TEMP, MASK1),
          $          AND(SHL(SOURCE(I), NB*MOD(LFIELD,NK)), MASK2))
     WHERE
           MASK1 = 2**(NB*(NK-1)) - 1,
           MASK2 = BITWISE COMPLEMENT OF MASK1,
           SHL (W, N) GIVES W SHIFTED LEFT N BIT POSITIONS,
           OR (X, Y), AND (X, Y) GIVE BITWISE LOGICAL FUNCTIONS.
0    TO CONVERT MPUPK TO UNIVAC ASCII FORTRAN (FTN), REPLACE LINE MP052387 BY
0          DATA NK /4/, ISTC /0/
0    AND LINE MP052415 BY
0          BITS (TEMP, 1, 9) = BITS (SOURCE(I), 9*MOD(LFIELD,4)+1, 9)
0    TO CONVERT MPUPK TO IBM 360/370 FORTRAN G/H, REPLACE LINE MP052377 BY
0          INTEGER DEST(1), BLANKS, TEMP
           LOGICAL*1 SOURCE(1), TC(4)
           EQUIVALENCE (TC, TEMP)
0    DELETE LINES MP052381 TO MP052389, DELETE LINES MP052401 TO  MP052411,  AND
     REPLACE LINE MP052415 BY
0          TC(1) = SOURCE(K)
0    ALTERNATIVELY,  THE FOLLOWING RECIPE WORKS (INEFFICIENTLY) ON MOST SYSTEMS.
     REPLACE LINES MP052377 TO MP052391 BY
0          INTEGER SOURCE(1), DEST(1)
           DATA IST /1H$/
0    AND REPLACE LINES MP052401 TO MP052425 BY
0          DECODE (K, 5, SOURCE) (DEST(I), I = 1, K)
         5 FORMAT (80A1)
           IF (DEST(K) .EQ. IST) RETURN
        10 LFIELD = K
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  5.3
0    TO CONVERT MPINIT AND THE DESCRIPTION DECK, LET
0          I = DIMENSION  OF  ARRAYS  FOR  MP  VARIABLES  (LINE  MPA00230 OF THE
               DESCRIPTION DECK AND LINE MP032851 OF MPINIT),
0          J = DIMENSION OF ARRAYS FOR PACKED MP VARIABLES (LINE MPA00200 OF THE
               DESCRIPTION DECK),
0          K = DIMENSION OF R IN COMMON (LINES MP032849 AND MP032851 OF MPINIT).
0    SUPPOSE  PRECISION EQUIVALENT TO AT LEAST D DECIMAL PLACES IS REQUIRED ON A
     MACHINE WITH EFFECTIVE WORDLENGTH W BITS (2**(W-1)-1 MUST BE  REPRESENTABLE
     AS A SIGNED INTEGER).
     THEN
           I = T + 2,
           J = INT((T+3)/2),
     AND
           K .LE. MAX (T*T + 15*T + 27, 14*T + 156),
     WHERE
           T = INT (2 + D*LOG(10)/(INT(W/2-2)*LOG(2)))
0    IS THE NUMBER OF (BASE B) DIGITS TO BE  USED  BY  THE  MP  ROUTINES.   (FOR
     SHARPER BOUNDS ON K, SEE THE COMMENTS ON MPBESJ AND MPLNGM IN SECTION 6.)
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  6.1
06 DESCRIPTION OF MP ROUTINES AND TEST PROGRAMS
 **********************************************
0    WE  ALWAYS GIVE FIRST THE METHOD OF CALLING THE MP ROUTINE DIRECTLY, SECOND
     (THIRD, ...) ALTERNATIVE METHODS  (IF  ANY)  USING  THE  AUGMENT  INTERFACE
     DESCRIBED IN SECTION 4.
0    UNLESS OTHERWISE NOTED, X, Y AND Z DENOTE INTEGER  ARRAYS  REPRESENTING  MP
     VARIABLES  (OFTEN CALLED MP NUMBERS),  ERR AND LV DENOTE LOGICAL VARIABLES,
     I, J, K, L, IX ETC. DENOTE SINGLE-PRECISION INTEGERS,  RX, RY  ETC.  DENOTE
     SINGLE-PRECISION REALS,  AND DX, DY ETC. DENOTE DOUBLE-PRECISION VARIABLES.
0    FOR DEFINITIONS OF B, T, M, LUN, MXR, R ETC. SEE SECTION 1.  SPACE REQUIRED
     MEANS  THE DIMENSION OF R IN COMMON (SEE SECTION 1).  IF NOT SPECIFIED, THE
     SPACE REQUIRED IS NO MORE THAN T+4 WORDS.  MPBESJ, MPGAM  AND  MPLNGM  HAVE
     THE LARGEST SPACE REQUIREMENTS.
0    TIME BOUNDS SUCH AS O(T**2) ARE AS T TENDS TO INFINITY WITH EVERYTHING ELSE
     FIXED.   FOR  THE  DEFINITION  OF  THE FUNCTION M(T) APPEARING IN SOME TIME
     BOUNDS, SEE THE DESCRIPTION OF MPMUL BELOW.
0  MPABS
   *****
     CALL MPABS (X, Y)  OR  Y = ABS (X)
0    SETS Y = ABS(X) FOR MP NUMBERS X AND Y.
0  MPADD
   *****
     CALL MPADD (X, Y, Z)  OR  Z = X + Y
0    ADDS X AND Y, FORMING RESULT IN Z, WHERE X, Y AND Z ARE MP  NUMBERS.   FOUR
     GUARD DIGITS ARE USED, AND THEN R*-ROUNDING (SEE MPADD2).
0  MPADDI
   ******
     CALL MPADDI (X, IY, Z)  OR  Z = X + IY
0    ADDS MP X TO INTEGER IY GIVING MP Z.
     SPACE = 2T+6 (BUT Z(1) MAY BE R(T+5)).
     AUGMENT USERS -  Z = X + IY IS PREFERABLE TO Z = IY + X.
0  MPADDQ
   ******
     CALL MPADDQ (X, I, J, Y)  OR  Z = ADDQ (X, I, J)
0    ADDS THE RATIONAL NUMBER I/J TO MP NUMBER X, MP RESULT IN Y.  SPACE = 2T+6.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  6.2
0  MPADD2
   ******
     CALL MPADD2 (X, Y, Z, Y1, TRUNC)
0    X,  Y  AND  Z ARE MP NUMBERS, Y1 AND TRUNC ARE INTEGERS.  (TO FORCE CALL BY
     REFERENCE RATHER THAN VALUE/RESULT, Y1 IS DECLARED AS AN  ARRAY,  BUT  ONLY
     Y1(1) IS EVER USED.)  SETS Z = X + Y1(1)*ABS(Y), WHERE Y1(1) = +- Y(1).  IF
     TRUNC IS ZERO R*-ROUNDING IS USED, OTHERWISE TRUNCATION.   (R*-ROUNDING  IS
     DEFINED  IN  KUKI  AND CODI, COMM. ACM 16(1973), 223.  SEE ALSO BRENT, IEEE
     TC-22(1973), 601.)  CALLED BY MPADD AND  MPSUB,  AND  NOT  RECOMMENDED  FOR
     INDEPENDENT USE.
0  MPADD3
   ******
     CALL MPADD3 (X, Y, S, MED, RE)
0    CALLED BY MPADD2, DOES  INNER  LOOPS  OF  ADDITION.   NOT  RECOMMENDED  FOR
     INDEPENDENT USE.
0  MPART1
   ******
     CALL MPART1 (N, Y)  OR  Y = ART1 (N)
0    COMPUTES MP Y = ARCTAN(1/N), ASSUMING INTEGER   N  .GT.  1.    USES  SERIES
     ARCTAN(X) = X - X**3/3 + X**5/5 - ..., SPACE = 2T+6.  CALLED BY MPPI.
0  MPASIN
   ******
     CALL MPASIN (X, Y)  OR  Y = ASIN (X)
0    RETURNS Y = ARCSIN(X), ASSUMING ABS(X) .LE. 1, FOR  MP  NUMBERS  X  AND  Y.
     RESULT  IS IN THE RANGE -PI/2 TO +PI/2.  METHOD IS TO USE MPATAN, SO TIME =
     O(M(T)T).  SPACE = 5T+12.
0  MPATAN
   ******
     CALL MPATAN (X, Y)  OR  Y = ATAN (X)
0    RETURNS  Y = ARCTAN(X) FOR MP X AND Y, USING AN O(M(T)T) METHOD WHICH COULD
     EASILY BE MODIFIED TO AN O(SQRT(T)M(T)) METHOD (AS IN MPEXP1).   RESULT  IS
     IN  THE  RANGE  -PI/2 TO +PI/2.  FOR AN ASYMPTOTICALLY FASTER METHOD, SEE -
     FAST MULTIPLE-PRECISION  EVALUATION  OF  ELEMENTARY  FUNCTIONS  (BY  R.  P.
     BRENT),  J.   ACM  23 (1976), 242-251, AND THE COMMENTS IN MPPIGL.  SPACE =
     5T+12.
0  MPBASA
   ******
     I = MPBASA (X)  OR  I = BASE (X)
0    RETURNS THE MP BASE (FIRST WORD IN COMMON).  X IS A DUMMY MP ARGUMENT.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  6.3
0  MPBASB
   ******
     CALL MPBASB (I, X)  OR  BASE (X) = I
0    SETS  THE MP BASE (FIRST WORD OF COMMON) TO I.  I SHOULD BE AN INTEGER SUCH
     THAT I .GE. 2 AND (8*I*I-1) IS REPRESENTABLE AS A SINGLE-PRECISION INTEGER.
     X IS A DUMMY MP ARGUMENT (AUGMENT EXPECTS ONE).
0    WARNING  SETTING  THE  BASE  DOES  NOT  CONVERT MP NUMBERS TO THE NEW BASE.
     *******  THIS CAN BE DONE BY CONVERTING TO DECIMAL USING MPOUT (OR MPOUTE),
     CHANGING THE BASE, AND CONVERTING BACK USING MPIN (OR MPINE).
0  MPBERN
   ******
     CALL MPBERN (N, P, X)  OR  X = BERN (N, P)
0    COMPUTES THE BERNOULLI NUMBERS B2 = 1/6, B4 = -1/30, B6 = 1/42, B8 = -1/30,
     B10  =  5/66,  B12  =  -691/2730,  ETC., DEFINED BY THE GENERATING FUNCTION
     Y/(EXP(Y)-1).   N AND P ARE SINGLE-PRECISION INTEGERS,  WITH  2*P .GE. T+2.
     X SHOULD BE A ONE-DIMENSIONAL INTEGER ARRAY OF DIMENSION AT LEAST P*N.  THE
     BERNOULLI  NUMBERS  B2, B4, ... , B(2N) ARE RETURNED IN PACKED FORMAT IN X,
     WITH B(2J) IN LOCATIONS X((J-1)*P+1), ... , X(P*J).  THUS, TO GET B(2J)  IN
     USUAL MP FORMAT IN Y,  ONE  SHOULD   CALL MPUNPK (X(IX), Y)   AFTER CALLING
     MPBERN, WHERE IX = (J-1)*P+1.
 
0    ALTERNATIVELY (SIMPLER BUT  NONSTANDARD)  -  X  MAY  BE  A  TWO-DIMENSIONAL
     INTEGER  ARRAY DECLARED WITH DIMENSION (P, N1), WHERE   N1 .GE. N   AND 2*P
     .GE.  T+2.    THEN B2, B4, ... , B(2N) ARE RETURNED IN PACKED FORMAT IN  X,
     WITH  B(2J) IN X(1,J), ... , X(P,J).  THUS, TO GET B(2J) IN USUAL MP FORMAT
     IN Y ONE SHOULD CALL MPUNPK (X(1, J), Y) AFTER CALLING MPBERN.
0    AUGMENT USERS - DECLARE
0          MULTIPAK X(N1)
0    WHERE   N1  .GE.  N,   AND USE  P = (NUMDIG(Y)+3)/2  AS THE SECOND ARGUMENT
     (HERE Y IS A DUMMY OF TYPE MULTIPLE), ASSUMING THAT THE  NUMBER  OF  DIGITS
     HAS NOT BEEN CHANGED BETWEEN INITIALIZATION AND THE COMPUTATION OF P.
 
     THE  WELL-KNOWN  RECURRENCE  IS  UNSTABLE (LOSING ABOUT 2J BITS OF RELATIVE
     ACCURACY IN THE COMPUTED B(2J)), SO WE USE A DIFFERENT  RECURRENCE  DERIVED
     BY EQUATING COEFFICIENTS IN
0          (EXP(Y)+1)*(2Y/(EXP(2Y)-1)) = 2Y/(EXP(Y)-1) .
0    THE RELATION
0          B(2J) = -2*((-1)**J)*FACTORIAL(2J)*ZETA(2J)/((2*PI)**(2J))
0    USED  IF ZETA(2J) IS EQUAL TO 1 TO WORKING ACCURACY.  THE RELATIVE ERROR IN
     B(2J) IS O((J**2)*(B**(1-T))).  TIME = O(T*(MIN(N,T)**2) + N*M(T)), SPACE =
     8T+18.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  6.4
0  MPBESJ
   ******
     CALL MPBESJ (X, NU, Y)  OR  Y = BESJ (X, NU)
0    RETURNS  Y = J(NU,X), THE FIRST-KIND BESSEL FUNCTION OF ORDER NU, FOR SMALL
     INTEGER NU, MP X AND Y.  ABS(NU)  MUST  BE  .LE.  MAX(B,  64).   METHOD  IS
     HANKELS  ASYMPTOTIC  EXPANSION  IF ABS(X) LARGE, THE POWER SERIES IF ABS(X)
     SMALL, AND THE BACKWARD RECURRENCE METHOD OTHERWISE.  RESULTS FOR  NEGATIVE
     ARGUMENTS  ARE  DEFINED BY J(-NU,X) = J(NU,-X) = ((-1)**NU)*J(NU,X).  ERROR
     COULD BE INDUCED BY O(B**(1-T)) PERTURBATIONS IN X AND Y.  TIME =  O(M(T)T)
     FOR  FIXED  X AND NU, INCREASES AS X AND NU INCREASE, UNLESS X LARGE ENOUGH
     FOR ASYMPTOTIC SERIES TO BE USED.   SPACE = 14T+156.
0  MPBES2
   ******
     CALL MPBES2 (X, NU, Y)
0    USES  THE BACKWARD RECURRENCE METHOD TO EVALUATE Y = J(NU,X), WHERE X AND Y
     ARE MP NUMBERS, NU (THE INDEX) IS AN INTEGER, AND J IS THE BESSEL  FUNCTION
     OF  THE  FIRST  KIND.   ASSUMES THAT 0 .LE. NU .LE. MAX(B,64) AND X .GT. 0.
     ALSO ASSUMED THAT  X  CAN  BE  CONVERTED  TO  REAL  WITHOUT  FLOATING-POINT
     OVERFLOW  OR UNDERFLOW.  FOR NORMALIZATION THE IDENTITY J(0,X) + 2*J(2,X) +
     2*J(4,X) + ... = 1  IS USED.  CALLED BY  MPBESJ  AND  NOT  RECOMMENDED  FOR
     INDEPENDENT USE.  SPACE = 8T+18.
0  MPCAM
   *****
     CALL MPCAM (A, X)  OR  X = CTM (A)  OR  X = CAM (A)
0    CONVERTS THE HOLLERITH STRING A TO AN MP NUMBER X.  A CAN BE  A  STRING  OF
     DIGITS  ACCEPTABLE  TO  ROUTINE  MPIN  AND TERMINATED BY A DOLLAR ($), E.G.
     7H-5.367$, OR ONE OF THE FOLLOWING SPECIAL STRINGS
           EPS  (MP MACHINE-PRECISION, SEE MPEPS),
           EUL  (EULERS CONSTANT 0.5772..., SEE MPEUL),
           MAXR (LARGEST VALID MP NUMBER, SEE MPMAXR),
           MINR (SMALLEST POSTIVE MP NUMBER, SEE MPMINR),
           PI   (PI = 3.14..., SEE MPPI).
     ACTUALLY,  ONLY  THE  FIRST  TWO  CHARACTERS  OF  THESE SPECIAL STRINGS ARE
     SIGNIFICANT.  SPACE REQUIRED IS NO MORE  THAN  5*T+L+14,  WHERE  L  IS  THE
     NUMBER  OF  CHARACTERS  IN THE STRING A (EXCLUDING $).  IF MXR IS LESS THAN
     3*T+L+11 THE STRING A WILL EFFECTIVELY BE TRUNCATED.
0    WARNING  AUGMENT USERS -  USE CAM(A) AND NOT CTM(A) IF A IS DECLARED AS  AN
     *******  INTEGER ARRAY.
0  MPCDM
   *****
     CALL MPCDM (DX, Z)  OR  Z = DX  OR  Z = CTM (DX)
0    CONVERTS DOUBLE-PRECISION DX TO  MP  Z.   SOME  NUMBERS  WILL  NOT  CONVERT
     EXACTLY  ON  MACHINES  WITH  BASE  OTHER  THAN  TWO, FOUR OR SIXTEEN.  THIS
     ROUTINE IS NOT CALLED BY ANY OTHER ROUTINE IN MP,  SO  MAY  BE  OMITTED  IF
     DOUBLE-PRECISION IS NOT AVAILABLE.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  6.5
0  MPCHK
   *****
     CALL MPCHK (I, J)
0    CHECKS  LEGALITY OF B, T, M, MXR AND LUN WHICH SHOULD BE SET IN COMMON (SEE
     SECTION 1).  THE CONDITION ON MXR (THE DIMENSION OF R IN  COMMON)  IS  THAT
     MXR .GE. (I*T + J).
0  MPCIM
   *****
     CALL MPCIM (IX, Z)  OR  Z = IX  OR  Z = CTM (IX)
0    CONVERTS INTEGER IX TO MP Z.  NOTE - IX SHOULD NOT BE THE SAME LOCATION  AS
     Z(1) IN CALL.
0  MPCLR
   *****
     CALL MPCLR (X, N)
0    SETS X(T+3), ... , X(N+2) TO ZERO.  USEFUL IF  PRECISION  IS  GOING  TO  BE
     INCREASED.
0  MPCMD
   *****
     CALL MPCMD (X, DZ)  OR  DZ = X  OR  DZ = CTD (X)
0    CONVERTS MP X TO DOUBLE-PRECISION DZ.  ASSUMES X IS IN ALLOWABLE RANGE  FOR
     DOUBLE-PRECISION  NUMBERS.   THERE IS SOME LOSS OF ACCURACY IF THE EXPONENT
     IS LARGE.
0  MPCMDE
   ******
     CALL MPCMDE (X, N, DX)
0    RETURNS  INTEGER  N  AND  DOUBLE-PRECISION  DX  SUCH  THAT MP  X = DX*10**N
     (APPROXIMATELY), WHERE  1 .LE. ABS(DX) .LT. 10  UNLESS X IS ZERO.   ASSUMED
     THAT X NOT SO LARGE OR SMALL THAT N OVERFLOWS.  SPACE = 6T+14.
0  MPCMEF
   ******
     CALL MPCMEF (X, N, Y)
0    GIVEN MP X, RETURNS INTEGER N AND MP Y SUCH THAT
           X = (10**N)*Y  AND  1 .LE. ABS(Y) .LT. 10
     (UNLESS X .EQ. 0, WHEN N .EQ. 0 AND Y .EQ. 0).  IT IS ASSUMED THAT X IS NOT
     SO LARGE OR SMALL THAT N OVERFLOWS.  SPACE = 5T+12.
0  MPCMF
   *****
     CALL MPCMF (X, Y)  OR  Y = CMF (X)  OR  Y = FRAC (X)
0    FOR MP X AND Y, RETURNS FRACTIONAL PART OF X IN Y,
     I.E.  Y = X - INTEGER PART OF X (TRUNCATED TOWARDS 0).
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  6.6
0  MPCMI
   *****
     CALL MPCMI (X, IZ)  OR  IZ = X  OR IZ = CTI (X)
0    CONVERTS  MP  X  TO  INTEGER  IZ,  ASSUMING  THAT X NOT TOO LARGE (ELSE USE
     MPCMIM).  X IS TRUNCATED TOWARDS ZERO.   IF  INT(X)  IS  TOO  LARGE  TO  BE
     REPRESENTED  AS  A  SINGLE-PRECISION  INTEGER, IZ IS RETURNED AS ZERO.  THE
     USER MAY CHECK FOR THIS POSSIBILITY BY TESTING IF
           ((X(1).NE.0) .AND. (X(2).GT.0) .AND. (IZ.EQ.0))
     IS TRUE ON RETURN FROM MPCMI.
0  MPCMIM
   ******
     CALL MPCMIM (X, Y)  OR  Y = CMIM (X)  OR  Y = INT (X)
0    RETURNS Y = INTEGER PART OF X (TRUNCATED TOWARDS 0), FOR MP X AND  Y.   USE
     IF Y TOO LARGE TO BE REPRESENTABLE AS A SINGLE-PRECISION INTEGER.
0  MPCMPA
   ******
     J = MPCMPA (X, Y)  OR  J = CMPA (X, Y)
0    COMPARES ABS(X) WITH ABS(Y) FOR MP X AND Y, RETURNING
           +1 IF ABS(X) .GT. ABS(Y),
           -1 IF ABS(X) .LT. ABS(Y),
            0 IF ABS(X) .EQ. ABS(Y).
0  MPCMPI
   ******
     J = MPCMPI (X, I)  OR  J = COMP (X, I)
0    COMPARES MP NUMBER X WITH INTEGER I, RETURNING
           +1 IF X .GT. I,
            0 IF X .EQ. I,
           -1 IF X .LT. I.
     SPACE = 2T+6.
0  MPCMPR
   ******
     J = MPCMPR (X, RI)  OR  J = COMP (X, RI)
0    COMPARES MP NUMBER X WITH REAL NUMBER RI, RETURNING
           +1 IF X .GT. RI,
            0 IF X .EQ. RI,
           -1 IF X .LT. RI.
     SPACE = 2T+6.
0  MPCMR
   *****
     CALL MPCMR (X, RZ)  OR  RZ = X  OR RZ = CTR (X)
0    CONVERTS MP X TO SINGLE-PRECISION RZ.  ASSUMES X IN ALLOWABLE RANGE.  THERE
     IS SOME LOSS OF ACCURACY IF THE EXPONENT IS LARGE.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  6.7
0  MPCMRE
   ******
     CALL MPCMRE (X, N, RX)
0    RETURNS  INTEGER  N  AND SINGLE-PRECISION REAL RX SUCH THAT MP X = RX*10**N
     (APPROXIMATELY), WHERE  1 .LE. ABS(RX) .LT. 10  UNLESS X IS ZERO.   ASSUMED
     THAT X NOT SO LARGE OR SMALL THAT N OVERFLOWS.  SPACE = 6T+14.
0  MPCOMP
   ******
     J = MPCOMP (X, Y)  OR  J = COMP (X, Y)
0    COMPARES THE MP NUMBERS X AND Y, RETURNING
           +1 IF X .GT. Y,
           -1 IF X .LT. Y,
            0 IF X .EQ. Y.
0  MPCOS
   *****
     CALL MPCOS (X, Y)  OR  Y = COS (X)
0    RETURNS Y = COS(X) FOR MP  X  AND  Y,  USING  MPSIN  AND  MPSIN1.   TIME  =
     O(M(T)T/LOG(T)),  SPACE = 5T+12.
0  MPCOSH
   ******
     CALL MPCOSH (X, Y)  OR  Y = COSH (X)
0    RETURNS MP Y = COSH(X) FOR MP X (NOT TOO LARGE).   TIME  =  O(SQRT(T)M(T)),
     SPACE = 5T+12.
0  MPCQM
   *****
     CALL MPCQM (I, J, Q)  OR  Q = CQM (I, J)  OR  Q = CTM (I, J)
0    CONVERTS THE RATIONAL NUMBER I/J TO MULTIPLE PRECISION Q.
0  MPCRM
   *****
     CALL MPCRM (RX, Z)  OR  Z = RX  OR  Z = CTM (RX)
0    CONVERTS  SINGLE-PRECISION  REAL RX TO MP Z.  SOME NUMBERS WILL NOT CONVERT
     EXACTLY ON MACHINES WITH BASE OTHER THAN TWO, FOUR OR SIXTEEN.
0  MPDAW
   *****
     CALL MPDAW (X, Y)  OR  Y = DAW (X)
0    RETURNS
           Y = DAWSONS INTEGRAL OF MP ARGUMENT X
             = EXP(-X**2)*(INTEGRAL FROM 0 TO X OF EXP(U**2)DU),
0    FOR MP X AND Y.    SPACE = 5T+17.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  6.8
0  MPDGA
   *****
     I = MPDGA (X, N)  OR  I = DIGIT (X, N)
0    RETURNS THE N-TH DIGIT OF THE MP NUMBER X FOR 1 .LE.  N  .LE.  T.   RETURNS
     ZERO IF X IS ZERO OR N .LE. 0 OR N .GT. T.
0  MPDGB
   *****
     CALL MPDGB (I, X, N)  OR  DIGIT (X, N) = I
0    SETS  THE  N-TH   DIGIT  OF THE MP NUMBER X TO I.    N MUST BE IN THE RANGE
     1  .LE.  N .LE. T,  I MUST BE IN THE RANGE  0 .LE. I .LT. B  (AND  I .NE. 0
     IF  N .EQ. 1).  THE SIGN AND EXPONENT OF X ARE UNCHANGED.
0  MPDIGA
   ******
     I = MPDIGA (X)  OR  I = NUMDIG (X)
0    RETURNS  THE  NUMBER OF MP DIGITS (SECOND WORD IN COMMON).  X IS A DUMMY MP
     ARGUMENT.
0  MPDIGB
   ******
     CALL MPDIGB (I, X)  OR  NUMDIG (X) = I
0    SETS  THE NUMBER OF MP DIGITS (SECOND WORD OF COMMON) TO I.  I SHOULD BE AN
     INTEGER (AT LEAST 2).  X IS A DUMMY MP ARGUMENT (AUGMENT EXPECTS ONE).
0    WARNING  MP  NUMBERS  MUST  BE  DECLARED  AS INTEGER ARRAYS OF DIMENSION AT
     *******  LEAST I+2. MPDIGB DOES NOT CHECK THIS.
0  MPDIV
   *****
     CALL MPDIV (X, Y, Z)  OR  Z = X/Y
0    SETS Z = X/Y, FOR MP X, Y AND Z.  MPERR IS CALLED IF Y IS  ZERO.   SPACE  =
     4T+10 (BUT Z(1) MAY BE R(3T+9)), TIME = O(M(T)).
0  MPDIVI
   ******
     CALL MPDIVI (X, IY, Z)  OR  Z = X/IY
0    DIVIDES MP X BY THE SINGLE-PRECISION INTEGER IY GIVING  MP  Z,  TIME  O(T).
     THIS  IS  MUCH FASTER THAN DIVISION BY AN MP NUMBER.  MPERR IS CALLED IF IY
     IS ZERO.
0  MPDUMP
   ******
     CALL MPDUMP (X)
0    DUMPS  OUT  THE  MP NUMBER X (SIGN, EXPONENT, FRACTION DIGITS) ON UNIT LUN.
     USEFUL FOR DEBUGGING.  EMBEDDED BLANKS SHOULD BE INTERPRETED AS ZEROS.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  6.9
0  MPEI
   ****
     CALL MPEI (X, Y)  OR  Y = EI (X)
0    RETURNS Y = EI(X) = -E1(-X)
               = (PRINCIPAL VALUE INTEGRAL FROM -INFINITY TO X OF EXP(U)/U DU),
0    FOR MP NUMBERS X AND Y, USING  THE  POWER  SERIES  FOR  SMALL  ABS(X),  THE
     ASYMPTOTIC  SERIES  FOR LARGE ABS(X), AND THE CONTINUED FRACTION FOR MEDIUM
     NEGATIVE X.  THE RELATIVE ERROR IN Y IS SMALL UNLESS X IS VERY CLOSE TO THE
     ZERO  0.37250741078136663446...  OF EI(X), AND THEN THE ABSOLUTE ERROR IN Y
     IS O(B**(1-T)).  IN ANY CASE  THE  ERROR  IN  Y  COULD  BE  INDUCED  BY  AN
     O(B**(1-T)) RELATIVE PERTURBATION IN X.  TIME = O(M(T)T), SPACE = 10T+38.
0  MPEPS
   *****
     CALL MPEPS (X)  OR  X = CTM (3HEPS)
0    SETS MP X TO  THE  (MULTIPLE-PRECISION)  MACHINE  PRECISION,  THAT  IS  THE
     SMALLEST POSITIVE NUMBER X SUCH THAT THE COMPUTED VALUE OF 1 + X IS GREATER
     THAN 1 .
0  MPEQ
   ****
     LV = MPEQ (X, Y))  OR  LV = (X .EQ. Y)  OR  IF (X .EQ. Y) ...
0    RETURNS  LOGICAL VALUE OF (X .EQ. Y) FOR MP X AND Y.  MPEQ MUST BE DECLARED
     LOGICAL UNLESS AUGMENT INTERFACE IS USED.
0  MPERF
   *****
     CALL MPERF (X, Y)  OR  Y = ERF (X)
0    RETURNS Y = ERF(X)
               = SQRT(4/PI)*(INTEGRAL FROM 0 TO X OF EXP(-U**2) DU)
0    FOR MP X AND Y,  SPACE = 5T+12.
0  MPERFC
   ******
     CALL MPERFC (X, Y)  OR  Y = ERFC (X)
0    RETURNS Y = ERFC(X) = 1 - ERF(X) FOR MP NUMBERS X AND Y,  USING  MPERF  AND
     MPERF3.   SPACE = 12T+26.
0  MPERF2
   ******
     CALL MPERF2 (X, Y)
0    RETURNS Y = EXP(X**2)*(INTEGRAL FROM 0 TO X OF EXP(-U*U) DU)
0    FOR  MP  NUMBERS X AND Y, USING THE POWER SERIES FOR SMALL X, AND MPEXP FOR
     LARGE X.  SPACE = 5T+12 (OR 3T+8 FOR SMALL X).   CALLED BY MPERF.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.10
0  MPERF3
   ******
     CALL MPERF3 (X, Y, IND, ERROR)
0    TRYS TO RETURN
0          Y = EXP(X**2)*(INTEGRAL FROM X TO INFINITY OF EXP(-U**2)DU),
     OR
           Y = EXP(-X**2)*(INTEGRAL FROM 0 TO X OF EXP(U**2) DU),
0    FOR  IND  ZERO  OR NONZERO RESPECTIVELY, IN BOTH CASES USING THE ASYMPTOTIC
     SERIES.  X AND Y ARE MP NUMBERS, IND AND  ERROR  ARE  INTEGERS.   ERROR  IS
     RETURNED  AS  0 IF X IS LARGE ENOUGH FOR THE ASYMPTOTIC SERIES TO GIVE FULL
     ACCURACY, OTHERWISE ERROR IS RETURNED AS 1 AND Y AS ZERO.  THE CONDITION ON
     X FOR ERROR .EQ. 0 IS APPROXIMATELY THAT
0          X .GT. SQRT(T*LN(B)).
0    SPACE = 4T+10. CALLED BY MPERF, MPERFC AND MPDAW.
0  MPERR
   *****
     CALL MPERR
0    THIS ROUTINE IS CALLED WHEN A FATAL ERROR  CONDITION  IS  ENCOUNTERED,  AND
     AFTER  A  MESSAGE HAS BEEN WRITTEN ON LOGICAL UNIT LUN.  AS SUPPLIED IN THE
     MP PACKAGE, MPERR WRITES A MESSAGE AND STOPS.  IT COULD BE MODIFIED TO GIVE
     A  TRACE-BACK  (E.G.  WITH  UNIVAC  1100  FORTRAN V THIS CAN BE OBTAINED BY
     REPLACING STOP BY RETURN 0).
0  MPEUL
   *****
     CALL MPEUL (G)  OR  G = CTM (3HEUL)
0    RETURNS  MP  G  =  EULERS  CONSTANT (GAMMA = 0.57721566...)  TO ALMOST FULL
     MULTIPLE-PRECISION ACCURACY.  THE METHOD WAS DISCOVERED BY EDWIN MC  MILLAN
     AND  RICHARD  BRENT,  AND  IS  FASTER  THAN  THE METHOD OF SWEENEY (USED IN
     EARLIER VERSIONS OF MPEUL).  TIME = O(T**2), SPACE = 5T+18.
0  MPEXP
   *****
     CALL MPEXP (X, Y)  OR  Y = EXP (X)
0    RETURNS  Y = EXP(X) FOR MP X AND Y.  EXP OF INTEGER AND FRACTIONAL PARTS OF
     X  ARE  COMPUTED  SEPARATELY.   SEE  ALSO  COMMENTS  IN  MPEXP1.   TIME   =
     O(SQRT(T)M(T)), SPACE = 4T+10.
0  MPEXPA
   ******
     I = MPEXPA (X)  OR  I = EXPON (X)
0    RETURNS THE EXPONENT OF THE MP NUMBER X (OR LARGEST NEGATIVE EXPONENT IF  X
     IS ZERO).
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.11
0  MPEXPB
   ******
     CALL MPEXPB (I, X)  OR  EXPON (X) = I
0    SETS  EXPONENT  OF  MP  NUMBER  X  TO  I UNLESS X IS ZERO (WHEN EXPONENT IS
     UNCHANGED).  X MUST BE A VALID MP NUMBER (EITHER ZERO OR NORMALIZED).
0  MPEXP1
   ******
     CALL MPEXP1 (X, Y)  OR  Y = EXP1 (X)
0    RETURNS
           Y = EXP(X) - 1
0    WHERE  X  AND  Y  ARE  MP  NUMBERS  AND    -1  .LT.  X  .LT.  1.   USES  AN
     O(SQRT(T).M(T))   ALGORITHM   DESCRIBED   IN   -    THE    COMPLEXITY    OF
     MULTIPLE-PRECISION   ARITHMETIC   (BY   R.  P.  BRENT),  IN  COMPLEXITY  OF
     COMPUTATIONAL PROBLEM SOLVING, UNIV. OF QUEENSLAND PRESS,  BRISBANE,  1976,
     126-165.   ASYMPTOTICALLY FASTER METHODS EXIST, BUT ARE NOT USEFUL UNLESS T
     IS VERY LARGE (SEE COMMENTS ON MPATAN AND MPPIGL).  SPACE = 3T+8.
0  MPEXT
   *****
     CALL MPEXT (I, J, X)
0    ROUTINE  CALLED  BY MPDIV AND MPSQRT TO ENSURE THAT RESULTS ARE REPRESENTED
     EXACTLY IN T-2 DIGITS IF THEY CAN BE.  X IS AN  MP  NUMBER,  I  AND  J  ARE
     INTEGERS.  NOT RECOMMENDED FOR INDEPENDENT USE.
0  MPGAM
   *****
     CALL MPGAM (X, Y)  OR  Y = GAM (X)
0    COMPUTES MP Y = GAMMA(X) FOR MP ARGUMENT X, USING MPGAMQ IF ABS(X) .LE. 100
     AND  240*X  IS  AN  INTEGER, OTHERWISE USING MPLNGM.  SPACE REQUIRED IS THE
     SAME AS FOR MPLNGM (THOUGH ONLY 9T+20 IF MPGAMQ IS USED).  TIME =  O(T**3).
0  MPGAMQ
   ******
     CALL MPGAMQ (I, J, X)  OR  Y = GAMQ (I, J)  OR  Y = GAM (I, J)
0    RETURNS
           X = GAMMA (I/J),
0    WHERE  X  IS  MULTIPLE-PRECISION  AND I, J ARE SMALL INTEGERS.   THE METHOD
     USED IS REDUCTION OF THE ARGUMENT TO (0, 1) AND THEN A DIRECT EXPANSION  OF
     THE  DEFINING  INTEGRAL  TRUNCATED  AT  A SUFFICIENTLY HIGH LIMIT, USING 2T
     DIGITS TO COMPENSATE FOR CANCELLATION.  TIME = O(T**2) IF I/J  IS  NOT  TOO
     LARGE.  IF I/J .GT. 100 (APPROXIMATELY) IT IS FASTER TO USE MPGAM.  (MPGAMQ
     IS VERY SLOW IF I/J IS  VERY  LARGE,  BECAUSE  THE  RELATION  GAMMA(X+1)  =
     X*GAMMA(X)  IS  USED REPEATEDLY.)  IF I OR J IS TOO LARGE, INTEGER OVERFLOW
     WILL OCCUR, AND THE RESULT WILL BE INCORRECT.  THIS WILL USUALLY  (BUT  NOT
     ALWAYS) BE DETECTED AND AN ERROR MESSAGE GIVEN.  SPACE = 6T+12.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.12
0  MPGCD
   *****
     CALL MPGCD (K, L)
0    RETURNS  K  = K/GCD AND L = L/GCD, WHERE GCD IS THE GREATEST COMMON DIVISOR
     OF INITIAL K AND L (SINGLE-PRECISION INTEGERS).
0  MPGCDA
   ******
     CALL MPGCDA (X, Y, Z)  OR  Z = GCD (X, Y)
0    RETURNS  Z = GREATEST COMMON DIVISOR OF X AND Y.  GCD (X, 0) = GCD (0, X) =
     ABS(X), GCD (X, Y) .GE. 0.  X, Y AND  Z  ARE  INTEGERS  REPRESENTED  AS  MP
     NUMBERS,  AND  MUST  SATISFY  ABS(X)  .LT.  B**T, ABS(Y) .LT. B**T.  TIME =
     O(T**2), SPACE = 4T+10.
0  MPGCDB
   ******
     CALL MPGCDB (X, Y)
0    RETURNS  (X,  Y) AS (X/Z, Y/Z) WHERE Z IS THE GCD OF INITIAL X AND Y, WHICH
     ARE INTEGERS REPRESENTED AS MP NUMBERS, AND MUST SATISFY ABS(X) .LT.  B**T,
     ABS(Y) .LT. B**T.  TIME = O(T**2), SPACE = 5T+12.
0  MPGE
   ****
     LV = MPGE (X, Y))  OR  LV = (X .GE. Y)  OR  IF (X .GE. Y) ...
0    RETURNS LOGICAL VALUE OF (X .GE. Y) FOR MP X AND Y.  MPGE MUST BE  DECLARED
     LOGICAL UNLESS AUGMENT INTERFACE IS USED.
0  MPGT
   ****
     LV = MPGT (X, Y))  OR  LV = (X .GT. Y)  OR  IF (X .GT. Y) ...
0    RETURNS LOGICAL VALUE OF (X .GT. Y) FOR MP X AND Y.  MPGT MUST BE  DECLARED
     LOGICAL UNLESS AUGMENT INTERFACE IS USED.
0  MPHANK
   ******
     CALL MPHANK (X, NU, Y, ERROR)
0    TRIES TO COMPUTE THE BESSEL FUNCTION J (NU,  X)  USING  HANKELS  ASYMPTOTIC
     SERIES.  NU IS A NONNEGATIVE INTEGER .LE. MAX (B, 64), ERROR IS AN INTEGER.
     RETURNS ERROR = 0 IF SUCCESSFUL (RESULT J (NU, X) IN Y),
             ERROR = 1 IF UNSUCCESSFUL (Y UNCHANGED).
     ROUNDING ERROR COULD BE INDUCED BY O(B**(1-T)) PERTURBATIONS IN  X  AND  Y.
     TIME  =  O(T**3),  SPACE  =  11T+24.  CALLED BY MPBESJ, NOT RECOMMENDED FOR
     INDEPENDENT USE.
0  MPIN
   ****
     CALL MPIN (C, X, N, ERROR)
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.13
0    CONVERTS THE FIXED-POINT DECIMAL NUMBER (READ UNDER NA1 FORMAT) IN C(1) ...
     C(N)  TO  AN  MP  NUMBER  IN  X.   IF C REPRESENTS A VALID NUMBER, ERROR IS
     RETURNED AS 0.  IF C DOES NOT REPRESENT A VALID NUMBER, ERROR  IS  RETURNED
     AS  1  AND  X  AS  ZERO.  LEADING AND TRAILING BLANKS ARE ALLOWED, EMBEDDED
     BLANKS (EXCEPT BETWEEN THE NUMBER AND ITS SIGN) ARE FORBIDDEN.  IF THERE IS
     NO  DECIMAL  POINT  ONE  IS  ASSUMED  TO  LIE JUST TO THE RIGHT OF THE LAST
     DECIMAL DIGIT.  X IS AN  MP  NUMBER,  C  AN  INTEGER  ARRAY,  N  AND  ERROR
     INTEGERS.  SPACE = 3T+11.
0  MPINE
   *****
     CALL MPINE (C, X, N, J, ERROR)
0    SAME AS MPIN EXCEPT THAT THE RESULT (X) IS MULTIPLIED BY 10**J, WHERE J  IS
     A  SINGLE-PRECISION INTEGER.  FOR DETAILS OF THE OTHER ARGUMENTS, SEE MPIN.
     USEFUL FOR FLOATING-POINT INPUT OF MP  NUMBERS.   THE  USER  CAN  READ  THE
     EXPONENT  INTO J (USING ANY SUITABLE FORMAT) AND THE FRACTION INTO C (USING
     A1 FORMAT), THEN CALL MPINE TO  CONVERT  TO  MULTIPLE-PRECISION.   SPACE  =
     5T+12.
0  MPINF
   *****
     CALL MPINF (X, N, UNIT, IF ORM, ERR) OR  ERR = MPINF (X, N, UNIT, IFORM)
                                          OR  IF (MPINF (X, N, UNIT, IFORM)) ...
0    READS  N  WORDS  FROM  LOGICAL  UNIT IABS(UNIT) USING FORMAT IN IFORM, THEN
     CONVERTS TO MP NUMBER X USING ROUTINE MPIN.  IFORM SHOULD CONTAIN A  FORMAT
     WHICH ALLOWS FOR READING N WORDS IN A1 FORMAT, E.G. 6H(80A1).
     ERR  RETURNED  AS TRUE IF MPIN COULD NOT INTERPRET INPUT AS AN MP NUMBER OR
     IF N NOT POSITIVE, OTHERWISE FALSE.  IF ERR IS TRUE THEN X IS  RETURNED  AS
     ZERO.  SPACE REQUIRED 3T+N+11.
0  MPINIT
   ******
     CALL MPINIT (I)  OR  INITIALIZE MP
0    DECLARES BLANK COMMON (USED BY MP PACKAGE) AND CALLS  MPSET  TO  INITIALIZE
     PARAMETERS.  I IS A DUMMY INTEGER ARGUMENT.  THE AUGMENT DECLARATION
           INITIALIZE MP
     CAUSES A CALL TO MPINIT TO BE GENERATED.
0    WARNING  AS DISTRIBUTED MPINIT ASSUMES OUTPUT UNIT 6, 43 DECIMAL PLACES, 10
     *******  MP DIGITS, MXR = 296.   IF THE AUGMENT DESCRIPTION DECK IS CHANGED
     THIS ROUTINE SHOULD BE CHANGED ACCORDINGLY (SEE SECTION 5).
0  MPIO
   ****
     CALL MPIO (C, N, UNIT, IFORM, ERR)
0    IF  UNIT .GT. 0  WRITES C(1), ... , C(N) IN FORMAT IFORM,
     IF  UNIT .LE. 0  READS  C(1), ... , C(N) IN FORMAT IFORM,
     IN  BOTH  CASES  USES  LOGICAL  UNIT  IABS(UNIT).  C IS AN INTEGER ARRAY OF
     DIMENSION AT LEAST N.  ERR IS RETURNED AS FALSE IFF N POSITIVE.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.14
0  MPKSTR
   ******
     CALL MPKSTR (X, Y)  OR  Y = X
0    SETS Y = X FOR PACKED MP NUMBERS X AND Y.  ASSUMES SAME  PACKED  FORMAT  AS
     MPPACK AND MPUNPK, I.E. TYPE MULTIPAK FOR AUGMENT USERS.
0  MPLE
   ****
     LV = MPLE (X, Y))  OR  LV = (X .LE. Y)  OR  IF (X .LE. Y) ...
0    RETURNS LOGICAL VALUE OF (X .LE. Y) FOR MP X AND Y.  MPLE MUST BE  DECLARED
     TYPE LOGICAL UNLESS AUGMENT INTERFACE USED.
0  MPLI
   ****
     CALL MPLI (X, Y)  OR  Y = LI (X)
0    RETURNS
           Y = LI(X) = LOGARITHMIC INTEGRAL OF X
             = (PRINCIPAL VALUE INTEGRAL FROM 0 TO X OF DU/LN(U)),
0    USING  MPEI.  X AND Y ARE MP NUMBERS, X .GE. 0, X .NE. 1.  ERROR IN Y COULD
     BE INDUCED BY AN O(B**(1-T)) RELATIVE PERTURBATION IN X FOLLOWED BY SIMILAR
     PERTURBATION  IN Y.  THUS RELATIVE ERROR IN Y IS SMALL UNLESS X IS CLOSE TO
     1 OR TO THE ZERO 1.45136923488338105028...  OF  LI(X).   TIME  =  O(M(T)T),
     SPACE = 10T+38.
0  MPLN
   ****
     CALL MPLN (X, Y)  OR  Y = LN (X)  OR  Y = LOG (X)
0    RETURNS Y = LN(X), FOR MP X AND Y, USING MPLNS.  THE INTEGER PART OF  LN(X)
     MUST   BE   REPRESENTABLE   AS   A   SINGLE-PRECISION   INTEGER.    TIME  =
     O(SQRT(T)M(T)).  FOR SMALL INTEGER  X,  MPLNI  IS  FASTER.   ASYMPTOTICALLY
     FASTER  METHODS  EXIST (E.G. THE GAUSS-SALAMIN METHOD, SEE MPLNGS), BUT ARE
     NOT USEFUL UNLESS T IS LARGE.  SEE COMMENTS ON MPATAN, MPEXP1  AND  MPPIGL.
     SPACE = 6T+14.
0  MPLNGM
   ******
     CALL MPLNGM (X, Y)  OR  Y = LNGM (X)
0    RETURNS MP Y = LN(GAMMA(X)) FOR POSITIVE MP X, USING  STIRLINGS  ASYMPTOTIC
     APPROXIMATION.  SLOWER THAN MPGAMQ (UNLESS X LARGE) AND USES MORE SPACE, SO
     USE MPGAMQ AND MPLN IF X IS RATIONAL AND NOT TOO LARGE,  SAY  X  LESS  THAN
     100.  TIME = O(T**3).  SPACE = 11T+24+NL*((T+3)/2),  WHERE NL IS THE NUMBER
     OF TERMS USED IN THE ASYMPTOTIC EXPANSION,  NL .LE. 2+0.125*T*LN(B).
0    MPLNGM, MPGAM AND MPBESJ REQUIRE MORE SPACE THAN ANY OTHER MP ROUTINES.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.15
0  MPLNGS
   ******
     CALL MPLNGS (X, Y)  OR  Y = LNGS (X)
0    RETURNS  Y  = LN(X) FOR MP X AND Y, USING THE GAUSS-SALAMIN ALGORITHM BASED
     ON THE ARITHMETIC-GEOMETRIC MEAN ITERATION (SEE  -  ANALYTIC  COMPUTATIONAL
     COMPLEXITY (ED. BY J. F. TRAUB), ACADEMIC PRESS, 1976, 151-176) UNLESS X IS
     CLOSE TO 1.  SPACE = 6T+26, TIME = O(LOG(T)M(T)) + O(T**2) IF ABS(X-1) .GE.
     1/B  AND  AS  FOR  MPLNS  OTHERWISE.   SLOWER  THAN  MPLN UNLESS T IS LARGE
     (GREATER THAN ABOUT 500) SO RECOMMENDED FOR TESTING PURPOSES ONLY.
0  MPLNI
   *****
     CALL MPLNI (N, X)  OR  X = LNI (N)
                        OR  X = LN (N)  OR  X = LOG (N)
0    RETURNS MP X =  LN(N)  FOR  SMALL  POSITIVE  INTEGER  N,  USING  A  RAPIDLY
     CONVERGING SERIES AND MPL235.  TIME = O(T**2), SPACE = 3T+8.
0  MPLNS
   *****
     CALL MPLNS (X, Y)  OR  Y = LNS (X)
0    RETURNS MP Y = LN(1+X) IF X IS AN MP NUMBER SATISFYING THE CONDITION
           ABS(X) .LT. 1/B,
     ERROR  OTHERWISE.   USES NEWTONS METHOD TO SOLVE THE EQUATION EXP1(-Y) = X,
     THEN REVERSES SIGN OF Y.  (HERE EXP1(Y) = EXP(Y)  -  1  IS  COMPUTED  USING
     MPEXP1).  TIME = O(SQRT(T).M(T)), SPACE = 5T+12.
0  MPLT
   ****
     LV = MPLT (X, Y))  OR  LV = (X .LT. Y)  OR  IF (X .LT. Y) ...
0    RETURNS LOGICAL VALUE OF (X .LT. Y) FOR MP X AND Y.  MPLT MUST BE  DECLARED
     TYPE LOGICAL UNLESS AUGMENT INTERFACE USED.
0  MPL235
   ******
     CALL MPL235 (I, J, K, X)
0    RETURNS
           X = LN((2**I)*(3**J)*(5**K)),
     FOR  MP  X  AND INTEGER I, J AND K.  LN(81/80), LN(25/24) AND LN(16/15) ARE
     CALCULATED FIRST.  (MPL235 COULD BE SPEEDED  UP  IF  THESE  CONSTANTS  WERE
     PRECOMPUTED  AND  SAVED.)   ASSUMED  THAT  I,  J  AND  K NOT TOO LARGE (SEE
     COMMENTS IN SOURCE).  TIME = O(T**2), SPACE = 3T+8.  CALLED BY  MPLNI,  NOT
     RECOMMENDED FOR INDEPENDENT USE.
0  MPMAX
   *****
     CALL MPMAX (X, Y, Z)  OR  Z = MAX (X, Y)
0    SETS Z = MAX (X, Y) WHERE X, Y AND Z ARE MULTIPLE-PRECISION.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.16
0  MPMAXR
   ******
     CALL MPMAXR (X)  OR  X = CTM (4HMAXR)
0    SETS X TO THE LARGEST POSSIBLE POSITIVE MP NUMBER.
0  MPMEXA
   ******
     I = MPMEXA (X)  OR  I = MAXEXP (X)
0    RETURNS  THE  MAXIMUM  ALLOWABLE  EXPONENT OF MP NUMBERS (THE THIRD WORD OF
     COMMON).  X IS A DUMMY MP ARGUMENT (AUGMENT EXPECTS ONE).
0  MPMEXB
   ******
     CALL MPMEXB (I, X)  OR  MAXEXP (X) = I
0    SETS  THE  MAXIMUM ALLOWABLE EXPONENT OF MP NUMBERS (I.E. THE THIRD WORD OF
     COMMON) TO I.  I SHOULD BE GREATER THAN T, AND 4*I SHOULD BE  REPRESENTABLE
     AS A SINGLE-PRECISION INTEGER.  X IS A DUMMY MP ARGUMENT.
0  MPMIN
   *****
     CALL MPMIN (X, Y, Z)  OR  Z = MIN (X, Y)
0    SETS Z = MIN (X, Y) WHERE X, Y AND Z ARE MULTIPLE-PRECISION.
0  MPMINR
   ******
     CALL MPMINR (X)  OR  X = CTM (4HMINR)
0    SETS X TO THE SMALLEST POSITIVE NORMALIZED MP NUMBER.
0  MPMLP
   *****
     CALL MPMLP (U, V, W, J)
0    PERFORMS INNER MULTIPLICATION LOOP FOR MPMUL.  CARRIES ARE  NOT  PROPAGATED
     IN INNER LOOP, WHICH SAVES TIME AT THE EXPENSE OF SPACE.
0  MPMUL
   *****
     CALL MPMUL (X, Y, Z)  OR  Z = X*Y
0    MULTIPLIES X AND Y, RETURNING RESULT IN Z, FOR MP X, Y AND Z.   THE  SIMPLE
     O(T**2)  ALGORITHM  IS  USED,  WITH  FOUR  GUARD  DIGITS  AND  R*-ROUNDING.
     ADVANTAGE IS TAKEN OF ZERO DIGITS IN  X,  BUT  NOT  IN  Y.   ASYMPTOTICALLY
     FASTER  ALGORITHMS  ARE  KNOWN  (SEE  KNUTH,  VOL. 2), BUT ARE DIFFICULT TO
     IMPLEMENT IN FORTRAN IN AN EFFICIENT AND MACHINE-INDEPENDENT MANNER.
0    IN  COMMENTS  ON  OTHER MP ROUTINES, M(T) IS THE TIME TO PERFORM T-DIGIT MP
     MULTIPLICATION.   THUS M(T) = O(T**2) WITH THE PRESENT  VERSION  OF  MPMUL,
     BUT M(T) = O(T.LOG(T).LOG(LOG(T))) IS THEORETICALLY POSSIBLE.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.17
0  MPMULI
   ******
     CALL MPMULI (X, IY, Z)  OR  Z = X*IY
0    MULTIPLIES  MP  X BY SINGLE-PRECISION INTEGER IY GIVING MP Z.  TIME = O(T),
     WHICH IS FASTER THAN MPMUL.  RESULT IS ROUNDED.  MULTIPLICATION BY 1 MAY BE
     USED TO NORMALIZE A NUMBER EVEN IF THE LAST DIGIT IS B.
     AUGMENT USERS -  Z = X*IY IS FASTER THAN Z = IY*X.
0  MPMULQ
   ******
     CALL MPMULQ (X, I, J, Y)  OR  Y = MULQ (X, I, J)
0    MULTIPLIES MP X BY I/J, GIVING MP Y.   HERE I AND  J  ARE  SINGLE-PRECISION
     INTEGERS, J. NE. 0 . TIME = O(T).
     AUGMENT USERS -  Y = MULQ (X, I, J) IS USUALLY FASTER THAN
                      Y = X * CTM (I,J).
0  MPMUL2
   ******
     CALL MPMUL2 (X, IY, Z, TRUNC)
0    MULTIPLIES MP X BY SINGLE-PRECISION INTEGER IY GIVING MP Z.  MULTIPLICATION
     BY 1 MAY BE USED TO NORMALIZE A NUMBER EVEN IF SOME DIGITS ARE GREATER THAN
     B-1.   RESULT  IS  ROUNDED IF (INTEGER) TRUNC IS ZERO, OTHERWISE TRUNCATED.
     CALLED BY MPMULI, NOT RECOMMENDED FOR INDEPENDENT USE.
0  MPNE
   ****
     LV = MPNE (X, Y))  OR  LV = (X .NE. Y)  OR  IF (X .NE. Y) ...
0    RETURNS  LOGICAL VALUE OF (X .NE. Y) FOR MP X AND Y.  MPNE MUST BE DECLARED
     TYPE LOGICAL UNLESS AUGMENT INTERFACE USED.
0  MPNEG
   *****
     CALL MPNEG (X, Y)  OR  Y = -X
0    SETS Y = -X FOR MP NUMBERS X AND Y.
0  MPNZR
   *****
     CALL MPNZR (RS, RE, Z, TRUNC)
0    ASSUMES LONG (I.E. (T+4)-DIGIT) FRACTION IN R, SIGN = RS,  EXPONENT  =  RE.
     NORMALIZES,  AND  RETURNS  MP RESULT IN Z.  INTEGER ARGUMENTS RS AND RE ARE
     NOT PRESERVED.  R*-ROUNDING IS USED IF (INTEGER) TRUNC IS  ZERO,  OTHERWISE
     RESULT  IS  TRUNCATED.   CALLED BY MPADD2, MPDIVI, MPMUL, MPMUL2, ETC., AND
     NOT RECOMMENDED FOR INDEPENDENT USE.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.18
0  MPOUT
   *****
     CALL MPOUT (X, C, P, N)
0    CONVERTS MP X TO FP.N FORMAT IN C, WHICH MAY BE PRINTED UNDER  PA1  FORMAT.
     NOTE THAT N = -1 IS ALLOWED, AND EFFECTIVELY GIVES IP FORMAT.  DIGITS AFTER
     THE DECIMAL POINT ARE  BLANKED  OUT  IF  THEY  COULD  NOT  BE  SIGNIFICANT.
     EFFICIENCY  IS  HIGHER  IF  B  IS  A  POWER OF 10 THAN IF NOT.  P AND N ARE
     INTEGERS, C IS AN INTEGER ARRAY OF DIMENSION AT LEAST P.  TIME  =  O(T**2),
     SPACE = 3T+11.
0  MPOUTE
   ******
     CALL MPOUTE (X, C, J, P)
0    ASSUMES X IS AN MP NUMBER AND C AN INTEGER ARRAY OF DIMENSION  AT  LEAST  P
     .GE. 4.  ON RETURN J IS THE EXPONENT (TO BASE TEN) OF X AND THE FRACTION IS
     IN C, READY TO BE PRINTED IN A1 FORMAT.  FOR EXAMPLE, WE COULD PRINT J  AND
     C  IN  (I10,  1X,  PA1)  FORMAT.  THE FRACTION HAS ONE PLACE BEFORE DECIMAL
     POINT AND P-3 AFTER.  J AND P ARE INTEGERS.    SPACE = 6T+14.
0  MPOUTF
   ******
     CALL MPOUTF (X, P, N, IFORM, ERR)  OR  ERR = MPOUTF (X, P, N, IFORM)
                                        OR  IF (MPOUTF (X, P, N, IFORM)) ...
0    WRITES MP NUMBER X ON LOGICAL UNIT LUN (FOURTH WORD OF  COMMON)  IN  FORMAT
     IFORM  AFTER CONVERTING TO FP.N DECIMAL REPRESENTATION USING ROUTINE MPOUT.
     FOR FURTHER DETAILS SEE COMMENTS ON MPOUT.  IFORM SHOULD CONTAIN  A  FORMAT
     WHICH ALLOWS FOR OUTPUT OF P WORDS IN A1 FORMAT, PLUS ANY DESIRED HEADINGS,
     SPACING ETC., FOR EXAMPLE
           24H(8H1HEADING/(11X,100A1)) .
     ERR IS RETURNED AS FALSE IFF P IS POSITIVE.  SPACE = 3T+P+11.
0  MPOUT2
   ******
     CALL MPOUT2 (X, C, P, N, NB)
0    SAME AS MPOUT EXCEPT THAT OUTPUT REPRESENTATION IS IN BASE NB, WHERE 2 .LE.
     NB  .LE.  16,  E.G.  NB  = 8 GIVES OCTAL OUTPUT, NB = 16 GIVES HEXADECIMAL.
     OUTPUT DIGITS ARE 0123456789ABCDEF.  X IS AN MP NUMBER,  P, N  AND  NB  ARE
     INTEGERS,  C  IS AN INTEGER ARRAY OF DIMENSION AT LEAST P.  TIME = O(T**2),
     SPACE = 3T+11.  CALLED BY MPOUT.
0  MPOVFL
   ******
     CALL MPOVFL (X)
0    CALLED  ON MULTIPLE-PRECISION OVERFLOW, THAT IS WHEN THE EXPONENT OF THE MP
     NUMBER X WOULD EXCEED M.  AT PRESENT EXECUTION IS TERMINATED WITH AN  ERROR
     MESSAGE  AFTER  CALLING  MPMAXR(X),  BUT  IT  WOULD  BE POSSIBLE TO RETURN,
     POSSIBLY UPDATING A COUNTER AND TERMINATING EXECUTION AFTER A PRESET NUMBER
     OF OVERFLOWS.  (ACTION COULD BE DETERMINED BY A FLAG IN LABELLED COMMON.)
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.19
0  MPPACK
   ******
     CALL MPPACK (X, Y)  OR  Y = X  OR  Y = CTP (X)
0    ASSUMES  THAT X IS AN MP NUMBER REPRESENTED AS USUAL IN AN INTEGER ARRAY OF
     DIMENSION AT LEAST T+2, AND Y IS AN INTEGER ARRAY  OF  DIMENSION  AT  LEAST
     INT((T+3)/2).   X  IS STORED IN A COMPACT FORMAT IN Y, AND MAY BE RETRIEVED
     BY CALLING MPUNPK (Y, X).   MPPACK  AND  MPUNPK  ARE  USEFUL  IF  SPACE  IS
     CRITICAL, FOR EXAMPLE WHEN WORKING WITH LARGE ARRAYS OF MP NUMBERS.
     AUGMENT USERS -  X IS TYPE MULTIPLE, Y IS TYPE MULTIPAK.
0  MPPI
   ****
     CALL MPPI (X)  OR  X = CTM (2HPI)
0    SETS MP X = PI TO THE AVAILABLE PRECISION.  USES THE FORMULA OF MACHIN  AND
     CALLS MPART1.  TIME = O(T**2), SPACE = 3T+8.
0  MPPIGL
   ******
     CALL MPPIGL (PI)
0    SETS  MP  PI  =  3.14159...  TO  THE   AVAILABLE   PRECISION.    USES   THE
     GAUSS-LEGENDRE ALGORITHM.  THIS METHOD REQUIRES TIME O(LN(T)M(T)), SO IT IS
     SLOWER THAN MPPI IF M(T) = O(T**2), BUT WOULD BE FASTER FOR LARGE  T  IF  A
     FASTER  MULTIPLICATION  ALGORITHM WERE USED (SEE COMMENTS ON MPMUL).  FOR A
     DESCRIPTION OF THE METHOD, SEE - MP  ZERO-FINDING  AND  THE  COMPLEXITY  OF
     ELEMENTARY  FUNCTION EVALUATION (BY R. P. BRENT), IN ANALYTIC COMPUTATIONAL
     COMPLEXITY (EDITED BY J. F. TRAUB), ACADEMIC PRESS, 1976, 151-176.  SPACE =
     6T+14.  RECOMMENDED MAINLY FOR TESTING PURPOSES.
0  MPPOLY
   ******
     CALL MPPOLY (X, Y, IC, N)
0    SETS Y = IC(1) + IC(2)*X + ... + IC(N)*X**(N-1),  WHERE  X  AND  Y  ARE  MP
     NUMBERS  AND  IC  IS AN INTEGER ARRAY OF DIMENSION AT LEAST N (GREATER THAN
     ZERO).  SPACE = 3T+8 (BUT Y(1) MAY BE R(2T+7)).
0  MPPWR
   *****
     CALL MPPWR (X, N, Y)  OR  Y = X**N
0    RETURNS  Y = X**N, FOR MP X AND Y, INTEGER N, WITH 0**0 = 1.  SPACE = 4T+10
     (2T+6 IS ENOUGH IF N NONNEGATIVE).
0  MPPWR2
   ******
     CALL MPPWR2 (X, Y, Z)  OR  Z = X**Y
0    RETURNS  Z  = X**Y FOR MP NUMBERS X, Y AND Z, WHERE X IS POSITIVE (X .EQ. 0
     ALLOWED IF Y .GT. 0).  SLOWER  THAN  MPPWR  AND  MPQPWR,  SO  USE  THEM  IF
     POSSIBLE.  SPACE = 7T+16.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.20
0  MPQPWR
   ******
     CALL MPQPWR (I, J, K, L, X)  OR  X = QPWR (I, J, K, L)
0    SETS MP X = (I/J)**(K/L) FOR INTEGERS I, J, K AND L.  USES MPROOT IF ABS(L)
     SMALL, OTHERWISE USES MPLNI AND MPEXP.  SPACE = 4T+10.
     AUGMENT USERS -  X = QPWR (I,J,K,L) IS USUALLY FASTER THAN
                      X = CTM(I,J)**CTM(K,L).
0  MPREC
   *****
     CALL MPREC (X, Y)  OR  Y = REC (X)
0    RETURNS Y = 1/X, FOR MP X  AND  Y.   SPACE  =  4T+10.   (BUT  Y(1)  MAY  BE
     R(3T+9)).   NEWTONS  METHOD  IS USED, SO FINAL ONE OR TWO DIGITS MAY NOT BE
     CORRECT.  CALLED BY MPDIV.
     AUGMENT USERS -  Y = REC(X) IS FASTER THAN Y = 1/X.
0  MPROOT
   ******
     CALL MPROOT (X, N, Y)  OR  Y = ROOT (X, N)
0    RETURNS  Y  =  X**(1/N)  FOR  INTEGER  N,  ABS(N) .LE. MAX (B, 64).  AND MP
     NUMBERS X AND Y, USING NEWTONS METHOD WITHOUT DIVISIONS.    SPACE  =  4T+10
     (BUT Y(1) MAY BE R(3T+9)).
     AUGMENT USERS -  Y = ROOT (X, N) IS FASTER THAN Y = X**CTM(1,N)
                      (AND Y = X**(1/N) IS INCORRECT AS 1/N IS USUALLY ZERO).
0  MPSET
   *****
     CALL MPSET (LUNIT, IDECPL, ITMAX2, MAXDR)
0    SETS  BASE  (B) AND NUMBER OF DIGITS (T) TO GIVE THE EQUIVALENT OF AT LEAST
     IDECPL DECIMAL DIGITS.  IDECPL SHOULD BE POSITIVE.  ITMAX2 IS THE DIMENSION
     OF ARRAYS USED FOR MP NUMBERS, SO AN ERROR OCCURS IF THE COMPUTED T EXCEEDS
     ITMAX2 - 2.  MPSET ALSO SETS
0          LUN = LUNIT (LOGICAL UNIT FOR ERROR MESSAGES),
           MXR = MAXDR (DIMENSION OF R IN COMMON, .GE. T+4), AND
           M = (W-1)/4 (MAXIMUM ALLOWABLE EXPONENT),
0    WHERE W IS THE LARGEST INTEGER OF THE FORM 2**K-1 WHICH IS REPRESENTABLE IN
     THE  MACHINE,   K .LE. 47.  (USUALLY K+1 = THE NUMBER OF BITS PER WORD, BUT
     THIS IS NOT TRUE ON CDC 6000/7000 MACHINES.)  THE COMPUTED B AND T  SATISFY
     (T-1)*LN(B)/LN(10) .GE. IDECPL   AND   8*B*B-1 .LE. W .
     APPROXIMATELY  MINIMAL  T  AND  MAXIMAL  B  SATISFYING THESE CONDITIONS ARE
     CHOSEN.  PARAMETERS LUNIT, IDECPL, ITMAX2 AND MAXDR ARE INTEGERS.
0    WARNING  MPSET  WILL  CAUSE   AN INTEGER OVERFLOW TO OCCUR IF WORDLENGTH IS
     *******   LESS  THAN  48  BITS.   IF  THIS  IS  NOT  ALLOWABLE,  CHANGE THE
     DETERMINATION OF W (DO 30 ... TO 30 W = WN) OR SET B, T,  M,  LUN  AND  MXR
     WITHOUT CALLING MPSET.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.21
0  MPSIGA
   ******
     I = MPSIGA (X)  OR  I = SGN (X)
0    RETURNS SIGN OF MP NUMBER X.
0  MPSIGB
   ******
     CALL MPSIGB (I, X)  OR  SGN (X) = I
0    SETS SIGN OF MP NUMBER X TO I.  I SHOULD BE 0,  +1  OR  -1.   EXPONENT  AND
     DIGITS OF X ARE UNCHANGED, BUT RESULT MUST BE A VALID MP NUMBER.
0  MPSIN
   *****
     CALL MPSIN (X, Y)  OR  Y = SIN (X)
0    RETURNS Y = SIN(X) FOR MP X AND Y, METHOD IS TO REDUCE X TO (-1, 1) AND USE
     MPSIN1, SO TIME = O(M(T)T/LOG(T)).  SPACE = 5T+12.
0  MPSINH
   ******
     CALL MPSINH (X, Y)  OR  Y = SINH (X)
0    RETURNS Y = SINH(X) FOR MP NUMBERS X AND Y, X NOT TOO LARGE.  METHOD IS  TO
     USE MPEXP OR MPEXP1,  TIME = O(SQRT(T)M(T)),  SPACE = 5T+12.
0  MPSIN1
   ******
     CALL MPSIN1 (X, Y, IS)
0    RETURNS
           Y = SIN(X)  IF IS .NE .0,
           Y = COS(X)  IF IS .EQ .0,
     USING THE TAYLOR SERIES.  ASSUMES ABS(X) .LE. 1.
     X AND Y ARE MP NUMBERS, IS IS AN INTEGER.  TIME  =  O(M(T)T/LOG(T)).   THIS
     COULD  BE REDUCED TO O(SQRT(T)M(T)) AS IN MPEXP1, BUT NOT WORTHWHILE UNLESS
     T IS VERY LARGE.   ASYMPTOTICALLY  FASTER  METHODS  ARE  DESCRIBED  IN  THE
     REFERENCES  GIVEN  IN COMMENTS ON MPATAN AND MPPIGL.  SPACE = 3T+8.  CALLED
     BY MPCOS AND MPSIN AND NOT RECOMMENDED FOR INDEPENDENT USE.
0  MPSQRT
   ******
     CALL MPSQRT (X, Y)  OR  Y = SQRT (X)
0    RETURNS  Y  = SQRT(X) USING SUBROUTINE MPROOT.  SPACE = 4T+10 (BUT Y(1) MAY
     BE R(3T+9)).  X AND Y ARE MP NUMBERS,  X .GT. 0.
0  MPSTR
   *****
     CALL MPSTR (X, Y)  OR  Y = X
0    SETS Y = X FOR MP X AND Y.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.22
0  MPSUB
   *****
     CALL MPSUB (X, Y, Z)  OR  Z = X - Y
0    SUBTRACTS  Y  FROM  X,  FORMING RESULT IN Z, FOR MP X, Y AND Z.  FOUR GUARD
     DIGITS ARE USED, AND THEN R*-ROUNDING (SEE MPADD2).
0  MPTAN
   *****
     CALL MPTAN (X, Y)  OR  Y = TAN (X)
0    SETS  Y  =  TAN(X)  FOR  MP  X  AND  Y.   USES  SUBROUTINE MPSIN1 SO TIME =
     O(M(T)T/LOG(T)).  SPACE = 6T+20.
0  MPTANH
   ******
     CALL MPTANH (X, Y)  OR  Y = TANH (X)
0    RETURNS  Y = TANH(X) FOR MP NUMBERS X AND Y, USING MPEXP OR MPEXP1.  TIME =
     O(SQRT(T)M(T)),  SPACE = 5T+12.
0  MPUNFL
   ******
     CALL MPUNFL (X)
0    CALLED ON MULTIPLE-PRECISION UNDERFLOW, THAT IS WHEN THE EXPONENT OF THE MP
     NUMBER X WOULD BE LESS THAN -M.  THE UNDERFLOWING NUMBER IS  SET  TO  ZERO.
     AN ALTERNATIVE WOULD BE TO CALL MPMINR (X) AND/OR RETURN, POSSIBLY UPDATING
     A COUNTER AND TERMINATING EXECUTION AFTER A PRESET  NUMBER  OF  UNDERFLOWS.
     (ACTION COULD BE DETERMINED BY A FLAG IN LABELLED COMMON.)
0  MPUNPK
   ******
     CALL MPUNPK (Y, X)  OR  X = Y
0    RESTORES THE MP NUMBER X WHICH  IS  STORED  IN  COMPRESSED  FORMAT  IN  THE
     INTEGER ARRAY Y.  FOR FURTHER DETAILS SEE SUBROUTINE MPPACK.
     AUGMENT INTERFACE USERS - X IS TYPE MULTIPLE,
                               Y IS TYPE MULTIPAK.
0  MPUPK
   *****
     CALL MPUPK (SOURCE, DEST, LDEST, LFIELD)
0    THIS  SUBROUTINE  UNPACKS  A  PACKED  HOLLERITH STRING (SOURCE) PLACING ONE
     CHARACTER PER WORD IN THE  ARRAY  DEST  (AS  IF  READ  IN  A1  FORMAT).  IT
     CONTINUES  UNPACKING  UNTIL  IT  FINDS  A  SENTINEL ($) OR UNTIL IT FINDS A
     COMPILER GENERATED SENTINEL (IF SO IMPLEMENTED)  OR  UNTIL  IT  HAS  FILLED
     LDEST  WORDS  OF  THE  ARRAY  DEST.   THE  LENGTH OF THE UNPACKED STRING IS
     RETURNED IN LFIELD.   THUS 0 .LE. LFIELD .LE. LDEST.
0    WARNING  MACHINE DEPENDENT - SEE SECTION 5 AND COMMENTS IN SOURCE.
     *******
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.23
0  MPZETA
   ******
     CALL MPZETA (N, X)  OR  X = ZETA (N)
0    RETURNS  MP  X = ZETA(N) FOR INTEGER N .GT. 1, WHERE ZETA(N) IS THE RIEMANN
     ZETA FUNCTION (THE SUM FROM I =  1  TO  INFINITY  OF  I**(-N)).   USES  THE
     EULER-MACLAURIN  SERIES UNLESS N = 2, 4, 6 OR 8.  IN THE WORST CASE SPACE =
     8T+18+NL*((T+3)/2), WHERE NL IS THE NUMBER OF  TERMS  USED  IN  THE  EULER-
     MACLAURIN SERIES, NL .LE. 1 + 0.1*T*LN(B).  TIME = O(T**3).
0  MP40D
   *****
     CALL MP40D (N, X)
0    OUTPUT ROUTINE CALLED BY TEST PROGRAM, WRITES MP X TO N DECIMAL  PLACES  ON
     UNIT LUN, ASSUMING -10 .LT. X .LT. 100.  SPACE = 3T+N+14.
0  MP40E
   *****
     CALL MP40E (N, X)
0    WRITES X(1), ... , X(N) ON UNIT  LUN,  WHERE  X  IS  AN  INTEGER  ARRAY  OF
     DIMENSION AT LEAST N .GE. 1.  CALLED BY MP40D.
0  MP40F
   *****
     CALL MP40F (N, X)
0    OUTPUT ROUTINE CALLED BY TEST2 PROGRAM, WRITES X TO N  SIGNIFICANT  FIGURES
     ON UNIT LUN,  N .GE. 2.  SPACE = 6T+N+17.
0  MP40G
   *****
     CALL MP40G (N, X)
0    WRITES X(1), ... , X(N) ON UNIT  LUN,  WHERE  X  IS  AN  INTEGER  ARRAY  OF
     DIMENSION AT LEAST N .GE. 1.  CALLED BY MP40F.
0  TEST
   ****
0    THIS MAIN PROGRAM COMPUTES THE CONSTANTS GIVEN IN APPENDIX A OF KNUTH,  THE
     ART OF COMPUTER PROGRAMMING, VOL. 3.  THE CONSTANTS ARE PRINTED IN THE SAME
     ORDER AS THEY ARE GIVEN IN KNUTH.
0    THE  CONSTANTS  ARE  COMPUTED  TO  40  DECIMAL  PLACES, BUT TO INCREASE THE
     ACCURACY IT IS ONLY NECESSARY TO CHANGE THE  STATEMENT  IDECPL  =  40,  AND
     POSSIBLY  THE  PARAMETERS  OF  THE  CALL TO MPSET AND THE DIMENSIONS OF THE
     ARRAYS (SEE TESTV PROGRAM).
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.24
0    TO RUN TEST THE FOLLOWING MP ROUTINES ARE REQUIRED - MPABS, MPADD,  MPADDI,
     MPADDQ,  MPADD2, MPADD3, MPART1, MPCHK, MPCIM, MPCLR, MPCMF, MPCMI, MPCMPI,
     MPCMPR, MPCMR, MPCOMP, MPCOS, MPCQM, MPCRM, MPDIV,  MPDIVI,  MPERR,  MPEUL,
     MPEXP,  MPEXP1,  MPEXT,  MPGAMQ, MPGCD, MPLN, MPLNI, MPLNS, MPL235, MPMAXR,
     MPMLP, MPMUL, MPMULI, MPMULQ, MPMUL2, MPNZR, MPOUT, MPOUT2,  MPOVFL,  MPPI,
     MPPWR,  MPQPWR,  MPREC, MPROOT, MPSET, MPSIN, MPSIN1, MPSQRT, MPSTR, MPSUB,
     MPUNFL, MP40D, AND MP40E.
0    CORRECT OUTPUT (EXCLUDING HEADINGS) IS AS FOLLOWS
0         1.4142135623 7309504880 1688724209 6980785697
          1.7320508075 6887729352 7446341505 8723669428
          2.2360679774 9978969640 9173668731 2762354406
          3.1622776601 6837933199 8893544432 7185337196
          1.2599210498 9487316476 7210607278 2283505703
          1.4422495703 0740838232 1638310780 1095883919
          1.1892071150 0272106671 7499970560 4759152930
          0.6931471805 5994530941 7232121458 1765680755
          1.0986122886 6810969139 5245236922 5257046475
          2.3025850929 9404568401 7991454684 3642076011
          1.4426950408 8896340735 9924681001 8921374266
          0.4342944819 0325182765 1128918916 6050822944
          3.1415926535 8979323846 2643383279 5028841972
          0.0174532925 1994329576 9236907684 8861271344
          0.3183098861 8379067153 7767526745 0287240689
          9.8696044010 8935861883 4490999876 1511353137
          1.7724538509 0551602729 8167483341 1451827975
          2.6789385347 0774763365 5692940974 6776441287
          1.3541179394 2640041694 5288028154 5137855193
          2.7182818284 5904523536 0287471352 6624977572
          0.3678794411 7144232159 5523770161 4608674458
          7.3890560989 3065022723 0427460575 0078131803
          0.5772156649 0153286060 6512090082 4024310422
          1.1447298858 4940017414 3427351353 0587116473
          1.6180339887 4989484820 4586834365 6381177203
          1.7810724179 9019798523 6504103107 1795491696
          2.1932800507 3801545655 9769659278 7382234616
          0.8414709848 0789650665 2502321630 2989996226
          0.5403023058 6813971740 0936607442 9766037323
          1.2020569031 5959428539 9738161511 4499907650
          0.4812118250 5960344749 7758913424 3684231352
          2.0780869212 3502753760 1322606117 7957677422
          0.3665129205 8166432701 2439158232 6694694543
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.25
0  TESTV
   *****
0    THIS MAIN PROGRAM (A VARIABLE  PRECISION  VERSION  OF  TEST)  COMPUTES  THE
     CONSTANTS  GIVEN  IN  APPENDIX A OF KNUTH, THE ART OF COMPUTER PROGRAMMING,
     VOL. 3.  THE CONSTANTS ARE PRINTED IN THE SAME ORDER AS THEY ARE  GIVEN  IN
     KNUTH.   THE CONSTANTS ARE GIVEN TO HIGH PRECISION IN - KNUTHS CONSTANTS TO
     1000 DECIMAL AND 1100 OCTAL PLACES (BY R. P. BRENT), ANU  COMPUTER  CENTRE,
     TECH. REPORT NUMBER 47, 1975 (UMT 30, MATH. COMP. 30 (1976), 668).
0    THE OUTPUT LOGICAL UNIT NUMBER AND THE NUMBER OF DECIMAL PLACES FOR WORKING
     AND  OUTPUT  ARE  READ  FROM UNIT 5 IN FORMAT (2I4).  WE ASSUME T .LE. 100,
     OTHERWISE THE DIMENSION STATEMENTS AND CALL TO MPSET MUST BE CHANGED.
0    SOME EXECUTION TIMES ARE
0    UNIVAC 1108 (FOR SE1D UNDER EXEC 8)
        40D       4.420 SECONDS
        60D       6.981
        80D      10.293
       100D      13.970
       200D      42.083
       400D     161.524
      1000D    1065.567
0    DEC KA10 (F10, NOOPT)
        40D      10.98  SECONDS
        60D      19.12
        80D      26.74
       100D      36.16
       200D     114.70
0    IBM 360/50 (FTN H, OPT = 2) (SLOWER VERSION OF MP THAN CURRENT ONE)
        40D      25.039 SECONDS
        60D      42.461
        80D      58.859
       100D      83.166
       200D     259.078
0    IBM 360/91 (FTN H EXTENDED, OPT = 2) (SLOWER VERSION)
        40D       2.20 SECONDS
0    IBM 370/168 (FTN H EXTENDED, OPT = 2) (SLOWER VERSION)
        40D       1.66 SECONDS
0    PDP 11/45 (DOS, NO FLOATING-POINT HARDWARE) (SLOWER VERSION)
        40D     128  SECONDS
        60D     226
        80D     370
       100D     548
0    CYBER 76 (FTN 4.2, OPT = 1) (SLOWER VERSION)
        40D       0.478 SECONDS
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE 6.26
0    TO RUN TESTV THE FOLLOWING MP ROUTINES ARE REQUIRED - MPABS, MPADD, MPADDI,
     MPADDQ,  MPADD2, MPADD3, MPART1, MPCHK, MPCIM, MPCLR, MPCMF, MPCMI, MPCMPI,
     MPCMPR, MPCMR, MPCOMP, MPCOS, MPCQM, MPCRM, MPDIV,  MPDIVI,  MPERR,  MPEUL,
     MPEXP,  MPEXP1,  MPEXT,  MPGAMQ, MPGCD, MPLN, MPLNI, MPLNS, MPL235, MPMAXR,
     MPMLP, MPMUL, MPMULI, MPMULQ, MPMUL2, MPNZR, MPOUT, MPOUT2,  MPOVFL,  MPPI,
     MPPWR,  MPQPWR,  MPREC, MPROOT, MPSET, MPSIN, MPSIN1, MPSQRT, MPSTR, MPSUB,
     MPUNFL, MP40D, MP40E, AND TIMEMP.
0    SEE COMMENTS ON TIMEMP BEFORE RUNNING TESTV.
 
0  TEST2
   *****
0    THIS MAIN PROGRAM TESTS VARIOUS MP ROUTINES, ESPECIALLY THOSE NOT CALLED BY
     PROGRAM TEST.  IT COMPUTES THE CONSTANTS GIVEN IN - COMPUTER APPROXIMATIONS
     (BY  HART,  CHENEY,  LAWSON, MAEHLY, MESZTENYI, RICE, THACHER AND WITZGALL,
     JOHN WILEY, 1968), APPENDIX C, PP. 182-183,  AND  VARIOUS  OTHER  CONSTANTS
     WHICH  ARE  DESCRIBED  IN  THE  COMMENTS.  THE CONSTANTS ARE COMPUTED TO 40
     SIGNIFICANT FIGURES, WITH WORKING  PRECISION  EQUIVALENT  TO  AT  LEAST  42
     SIGNIFICANT  FIGURES.   TO  INCREASE THE PRECISION, IT IS ONLY NECESSARY TO
     ALTER THE STATEMENT IDECPL = 40, AND PERHAPS INCREASE THE DIMENSIONS OF THE
     ARRAYS (AND ALTER THE CALL TO MPSET ACCORDINGLY).
0    TO RUN TEST2 THE FOLLOWING MP ROUTINES ARE REQUIRED - MPABS, MPADD, MPADDI,
     MPADDQ,  MPADD2,  MPADD3,  MPART1,  MPASIN, MPATAN, MPBERN, MPBESJ, MPBES2,
     MPCDM, MPCHK, MPCIM, MPCLR, MPCMD, MPCMDE, MPCMEF,  MPCMF,  MPCMI,  MPCMIM,
     MPCMPA, MPCMPI, MPCMPR, MPCMR, MPCMRE, MPCOMP, MPCOS, MPCOSH, MPCQM, MPCRM,
     MPDAW, MPDIV, MPDIVI, MPDUMP, MPEI, MPEPS, MPERF, MPERFC,  MPERF2,  MPERF3,
     MPERR,  MPEUL,  MPEXP,  MPEXP1,  MPEXT, MPGAM, MPGAMQ, MPGCD, MPHANK, MPIN,
     MPLI, MPLN, MPLNGM, MPLNI, MPLNS, MPL235,  MPMAXR,  MPMINR,  MPMLP,  MPMUL,
     MPMULI,  MPMULQ,  MPMUL2,  MPNEG,  MPNZR,  MPOUT,  MPOUTE,  MPOUT2, MPOVFL,
     MPPACK, MPPI, MPPIGL, MPPOLY, MPPWR, MPPWR2, MPQPWR, MPREC, MPROOT,  MPSET,
     MPSIN, MPSIN1, MPSINH, MPSQRT, MPSTR, MPSUB, MPTAN, MPTANH, MPUNFL, MPUNPK,
     MPZETA, MP40D, MP40E, MP40F AND MP40G.
0    THE  CORRECT  OUTPUT  TO BE EXPECTED FROM THE TEST2 PROGRAM IS INDICATED IN
     THE COMMENTS IN THE SOURCE OF TEST2.
0  TIMEMP
   ******
     REAL VARIABLE = TIMEMP (I)
0    CALLED  BY  TESTV  MAIN  PROGRAM,  SHOULD  RETURN  THE  EXECUTION  TIME  IN
     FLOATING-POINT SECONDS FROM SOME ARBITRARY POINT.   THE  ARGUMENT  I  IS  A
     DUMMY.
0    NOTE  TIMEMP AS SUPPLIED WITH THE MP PACKAGE WRITES A MESSAGE ON  UNIT  LUN
     ****  AND RETURNS 0.0 .  THE BODY OF TIMEMP SHOULD BE REPLACED BY  SUITABLE
     MACHINE-DEPENDENT STATEMENTS.
1                    MP USERS GUIDE (AUGUST 1978)                      PAGE  7.1
07 INDEX OF LINE NUMBERS
 ***********************
0    THE  STARTING  LINE  SEQUENCE  NUMBERS  (GIVEN  IN COLUMNS 73-80) OF THE MP
     ROUTINES (VERSION 780802) ARE AS FOLLOWS.   THE  MP  PACKAGE  WAS  NUMBERED
     MP000010  TO  MP064410 ON 16 SEPT. 1976.  LINES INSERTED, CHANGED, OR MOVED
     SINCE THEN HAVE NUMBERS NOT DIVISIBLE BY 10 OR STARTING MPA...
0      AUG DECK  MPA00010         MPDIVI    MP020380          MPMLP     MP038390
       COMMENTS  MP000061         MPDUMP    MP021510          MPMUL     MP038490
       EXAMPLE   MP005460         MPEI      MP021770          MPMULI    MP039240
       JACOBI    MPA01000         MPEPS     MP022950          MPMULQ    MP039340
       MPABS     MP006190         MPEQ      MP023221          MPMUL2    MP039600
       MPADD     MP006270         MPERF     MP023240          MPNE      MP040461
       MPADDI    MP006350         MPERFC    MP023810          MPNEG     MP040480
       MPADDQ    MP006510         MPERF2    MP024310          MPNZR     MP040560
       MPADD2    MP006630         MPERF3    MP024840          MPOUT     MP041370
       MPADD3    MP007230         MPERR     MP025390          MPOUTE    MP041520
       MPART1    MP008130         MPEUL     MP025580          MPOUTF    MP041781
       MPASIN    MP008610         MPEXP     MP026340          MPOUT2    MP041840
       MPATAN    MP008990         MPEXPA    MP027271          MPOVFL    MP043230
       MPBASA    MP009551         MPEXPB    MP027311          MPPACK    MP043440
       MPBASB    MP009571         MPEXP1    MP027370          MPPI      MP043710
       MPBERN    MP009610         MPEXT     MP028000          MPPIGL    MP043970
       MPBESJ    MP010760         MPGAM     MP028240          MPPOLY    MP044420
       MPBES2    MP011900         MPGAMQ    MP029050          MPPWR     MP044700
       MPCAM     MP012491         MPGCD     MP029311          MPPWR2    MP045130
       MPCDM     MP012580         MPGCDA    MP029371          MPQPWR    MP045440
       MPCHK     MP013250         MPGCDB    MP029531          MPREC     MP046170
       MPCIM     MP013760         MPGE      MP030521          MPROOT    MP046980
       MPCLR     MP014030         MPGT      MP030541          MPSET     MP048040
       MPCMD     MP014160         MPHANK    MP030560          MPSIGA    MP048741
       MPCMDE    MP014560         MPIN      MP031390          MPSIGB    MP048761
       MPCMEF    MP014790         MPINE     MP032570          MPSIN     MP048810
       MPCMF     MP015500         MPINF     MP032761          MPSINH    MP049480
       MPCMI     MP015820         MPINIT    MP032821          MPSIN1    MP049860
       MPCMIM    MP016250         MPIO      MP032921          MPSQRT    MP050440
       MPCMPA    MP016480         MPKSTR    MP032961          MPSTR     MP050680
       MPCMPI    MP016640         MPLE      MP033001          MPSUB     MP050890
       MPCMPR    MP016800         MPLI      MP033020          MPTAN     MP050980
       MPCMR     MP016960         MPLN      MP033380          MPTANH    MP051610
       MPCMRE    MP017310         MPLNGM    MP033940          MPUNFL    MP052000
       MPCOMP    MP017530         MPLNGS    MP034810          MPUNPK    MP052150
       MPCOS     MP017880         MPLNI     MP035580          MPUPK     MP052341
       MPCOSH    MP018170         MPLNS     MP036630          MPZETA    MP052440
       MPCQM     MP018430         MPLT      MP037281          MP40D     MP053590
       MPCRM     MP018630         MPL235    MP037300          MP40E     MP053760
       MPDAW     MP019260         MPMAX     MP037830          MP40F     MP053900
       MPDGA     MP019741         MPMAXR    MP037950          MP40G     MP054080
       MPDGB     MP019781         MPMEXA    MP038051          TEST      MP054220
       MPDIGA    MP019841         MPMEXB    MP038071          TESTV     MP056030
       MPDIGB    MP019861         MPMIN     MP038110          TEST2     MP057940
       MPDIV     MP019900         MPMINR    MP038230          TIMEMP    MP064140
1
 END OF MP USER'S GUIDE
